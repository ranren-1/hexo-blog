<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构应试 | Ranren</title><meta name="author" content="ranren"><meta name="copyright" content="ranren"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构一、绪论基本概念： 数据结构：研究非数值的程序设计问题中计算机的操作对象以及它们之间的关系和操作的学科。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。  数据：是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中被计算机程序处理的符号的总称。  数据元素：数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。  数据项：数据不可分割的最小单位。若干个数据项可以">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构应试">
<meta property="og:url" content="https://ranren.zeabur.app/2024/11/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%94%E8%AF%95/index.html">
<meta property="og:site_name" content="Ranren">
<meta property="og:description" content="数据结构一、绪论基本概念： 数据结构：研究非数值的程序设计问题中计算机的操作对象以及它们之间的关系和操作的学科。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。  数据：是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中被计算机程序处理的符号的总称。  数据元素：数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。  数据项：数据不可分割的最小单位。若干个数据项可以">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/10/23/txgP5ysfRUvCk6p.jpg">
<meta property="article:published_time" content="2024-11-21T15:26:57.000Z">
<meta property="article:modified_time" content="2024-12-02T07:28:25.763Z">
<meta property="article:author" content="ranren">
<meta property="article:tag" content="应试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/10/23/txgP5ysfRUvCk6p.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ranren.zeabur.app/2024/11/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%94%E8%AF%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构应试',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-02 15:28:25'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-color: #001B33;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avater.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://github.com/ranren-1/"><i class="fa-fw fas fa-link"></i><span> link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://s2.loli.net/2024/10/23/txgP5ysfRUvCk6p.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/avater.jpg" alt="Logo"><span class="site-name">Ranren</span></a><a class="nav-page-title" href="/"><span class="site-name">数据结构应试</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://github.com/ranren-1/"><i class="fa-fw fas fa-link"></i><span> link</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">数据结构应试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-21T15:26:57.000Z" title="发表于 2024-11-21 23:26:57">2024-11-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-02T07:28:25.763Z" title="更新于 2024-12-02 15:28:25">2024-12-02</time></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h2><h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h4><ol>
<li><p><strong>数据结构：研究非数值的程序设计问题中计算机的操作对象以及它们之间的关系和操作的学科。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</strong></p>
</li>
<li><p><strong>数据：是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中被计算机程序处理的符号的总称。</strong></p>
</li>
<li><p><strong>数据元素：数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。</strong></p>
</li>
<li><p><strong>数据项：数据不可分割的最小单位。若干个数据项可以组成一个数据元素。</strong></p>
</li>
<li><p><strong>数据对象：性质相同的数据元素的集合，是数据的一个子集。</strong></p>
</li>
<li><p>结构：数据元素互相之间的关系。</p>
</li>
<li><p><strong>4类数据结构的基本结构：集合，线性结构，树形结构，图状结构或网状结构。</strong></p>
</li>
<li><p>数据结构的形式定义 数据结构是一个二元组 DS&#x3D;(D,S) D:数据元素的有限集，S：D上的关系的有限集。</p>
</li>
<li><p><strong>逻辑结构：数据元素之间的逻辑关系。</strong></p>
</li>
<li><p><strong>存储结构（物理结构）：数据结构在计算机中的表示，包含数据元素的表示和关系的表示。</strong></p>
</li>
<li><p>位：计算机表示信息的最小单位是二进制数的一位。可用若干个位组合成的一个位串表示一个数据元素，通常称这个位串为元素或结点。</p>
</li>
<li><p>数据域：当数据元素由若干数据项组成时，位串中对应于各个数据项的子位串称为数据域。</p>
</li>
<li><p>数据元素之间的关系在计算机中存在两种表示方法：顺序映像和非顺序映像，并得到两种不同的存储结构：顺序存储结构和链式存储结构。</p>
</li>
<li><p>顺序映像的特点：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。</p>
</li>
<li><p>非顺序映像的特点：借助指示元素储存地址的指针表示数据元素之间的逻辑关系。</p>
</li>
<li><p>算法的设计取决于选定的数据（逻辑结构）结构，算法的实现依赖于采用的存储结构。</p>
</li>
<li><p>数据类型：一个值的集合和定义在这个值集上的一堆操作的总称。       </p>
</li>
<li><p>高级程序语言的数据类型可以分为：原子类型（不可分解）和结构类型（可分解）。</p>
</li>
<li><p>抽象数据类型：指一个数学模型以及定义在该模型上的一组操作。</p>
</li>
<li><p><strong>算法：是对特定问题求解步骤的一种描述，它是指令的有限序列，每一条指令表示一个或多个操作。具有5个重要特性：有穷性，确定性，可行性，输入，输出。</strong></p>
</li>
<li><p><strong>算法设计的要求：正确性，可读性，健壮性，效率与低存储量需求。</strong></p>
</li>
<li><p>算法效率的度量：事后统计的方法，事前分析估计。</p>
</li>
<li><p><strong>重点：时间复杂度的计算。</strong></p>
</li>
<li><p>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度</p>
</li>
<li><p><strong>若额外的空间相对于输入数据量来说是常数，则称此算法为原地工作。</strong></p>
</li>
</ol>
<h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><p>线性结构的特点：</p>
<ul>
<li>存在唯一一个被称为”第一个“的数据元素</li>
<li>存在唯一一个被称为”最后一个“的数据元素。</li>
<li>除第一个元素以外，集合中的每一个数据元素均只有一个前驱</li>
<li>除最后一个元素以外，集合中的每一个元素均只有一个后继。</li>
</ul>
<h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><p>线性表的顺序存储结构中，逻辑上相邻的元素在物理上也是相邻的。</p>
<p>优点：</p>
<ol>
<li>顺序表的内存空间连续。</li>
<li>尾插、尾删效率较高，时间复杂度是O(1)。</li>
<li>支持随机访问，可以高效的按下标进行操作，时间复杂度是O(1)。</li>
</ol>
<p>缺点：需要一段连续的空间，可能造成较多的外部碎片。</p>
<ol>
<li>在顺序表中间插入或删除元素时都涉及到元素的移动，效率较低，时间复杂度为O(N)。</li>
<li>顺序表长度固定，有时需要扩容。</li>
</ol>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h5 id="逆置链表"><a href="#逆置链表" class="headerlink" title="逆置链表"></a>逆置链表</h5><p>带头结点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(List &amp;L)</span> </span>&#123;</span><br><span class="line">    List p = L-&gt;next;</span><br><span class="line">    List p_next;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p_next = p-&gt;next;</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">        p = p_next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不带头节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(List&amp; L)</span> </span>&#123;</span><br><span class="line">    List p;</span><br><span class="line">    p = L;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        List q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        p-&gt;next = L;</span><br><span class="line">        L = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点<br>链表的内存空间不连续。</p>
<p>如果知道要处理节点的前一个位置，则进行插入和删除的复杂度为O(1);</p>
<p>如果不知道要处理节点的前一个位置，则进行插入和删除的复杂度为O(N)。</p>
<p>头插、头删的效率高，时间复杂度是O(1)。</p>
<p>没有空间限制，不会溢出，可以存储很多元素。</p>
<p>缺点：<br>链表不支持随机访问，查找元素效率低，需要遍历节点，时间复杂度是O(1)。</p>
<p>特点：</p>
<ul>
<li>每一个结点中包括两个域：数据域与指针域。</li>
<li>只包含一个指针的被称为线性链表或单链表。</li>
<li>整个链表的存取必须从头节点开始。</li>
</ul>
<h5 id="给定数组建立链表"><a href="#给定数组建立链表" class="headerlink" title="给定数组建立链表"></a>给定数组建立链表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkedList</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    LinkedList* next;</span><br><span class="line">&#125; LL, * LP;<span class="comment">//结点与指向结点的指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(LP&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L = <span class="keyword">new</span> LL;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateLinkedListByHead</span><span class="params">(LP&amp; L, <span class="type">int</span>* Arr, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LP q = L;</span><br><span class="line">    q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//头插法构建链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LP p = <span class="keyword">new</span> LL;</span><br><span class="line">        p-&gt;data = Arr[i];</span><br><span class="line">        p-&gt;next = q-&gt;next;</span><br><span class="line">        q-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateLinkedListByTail</span><span class="params">(LP&amp; L, <span class="type">int</span>* Arr, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LP q = L; <span class="comment">//尾插法构建链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LP p = <span class="keyword">new</span> LL;</span><br><span class="line">        p-&gt;data = Arr[i];</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        q-&gt;next = p;</span><br><span class="line">        q = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printfLink</span><span class="params">(LP Head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LP p = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//int n;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LP Head;</span><br><span class="line">    <span class="built_in">InitList</span>(Head);<span class="comment">//初始化链表头节点</span></span><br><span class="line">    <span class="comment">//cin &gt;&gt; n;</span></span><br><span class="line">    <span class="comment">//int* arr = new int[n];</span></span><br><span class="line">    <span class="comment">//for (int i = 0; i &lt; n; i++)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    cin &gt;&gt; arr[i];</span></span><br><span class="line">    <span class="comment">//&#125;//建立动态数组</span></span><br><span class="line">    <span class="type">int</span> Arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;<span class="comment">//建立静态给定数组</span></span><br><span class="line">    <span class="built_in">CreateLinkedListByTail</span>(Head, Arr, <span class="number">10</span>);<span class="comment">//尾插法将给定数组建立为链表,使用这种方法输出时数组为原来的顺序</span></span><br><span class="line">    <span class="comment">//CreateLinkedListByHead(Head, Arr,10);//头插法，使用该方法输出的值尾原数组的逆序</span></span><br><span class="line">    <span class="built_in">printfLink</span>(Head);<span class="comment">//打印所建立的链表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="带头节点链表和不带头结点链表"><a href="#带头节点链表和不带头结点链表" class="headerlink" title="带头节点链表和不带头结点链表"></a>带头节点链表和不带头结点链表</h5><p>带头结点与不带头结点的区别</p>
<p>带头结点时不管是否为空表,头指针的值都不会变化,都指向头结点。而不带头结点则需要根据不同情况来修改头指针的值。 不带头节点写代码不方便,需要专门写一段代码来解决第一个节点。 所以操作不统一,有所不便,所以绝大数时候使用带头结点的方式较为方便。</p>
<h6 id="带头结点链表"><a href="#带头结点链表" class="headerlink" title="带头结点链表"></a>带头结点链表</h6><p>头结点的数据域中一般不存储输入的数据，反而会存储类似于链表长度之类的信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带头节点链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> data;			<span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LNode</span>* next; <span class="comment">//指针指向下一个节点</span></span><br><span class="line">&#125;LL, * LP;   <span class="comment">//LinkList等价于LNode *,前者强调链表，后者强调结点</span></span><br><span class="line"><span class="comment">//初始化一个头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LP&amp; Head)</span> </span>&#123;</span><br><span class="line">	  <span class="comment">//空表</span></span><br><span class="line">	Head = <span class="keyword">new</span> LL;</span><br><span class="line">	Head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断单链表是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LP L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (L == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求表的长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(LP L)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	LP p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		len++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入指定的位置</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(LP&amp; L, <span class="type">int</span> i, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">	LP p = L;</span><br><span class="line">	LP q = <span class="keyword">new</span> LL;</span><br><span class="line">	q-&gt;data = e;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	q-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = q;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按位序删除（带头结点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(LP&amp; L, <span class="type">int</span> i, <span class="type">int</span>&amp; e)</span> </span>&#123;</span><br><span class="line">	LP p = L;</span><br><span class="line">	LP q = <span class="keyword">new</span> LL;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		q = p;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	e = p-&gt;data;</span><br><span class="line">	q-&gt;next = p-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定结点后插操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateLinkedListByHead</span><span class="params">(LP&amp; L, <span class="type">int</span>* Arr, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LP q = L;</span><br><span class="line">	q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//头插法构建链表</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		LP p = <span class="keyword">new</span> LL;</span><br><span class="line">		p-&gt;data = Arr[i];</span><br><span class="line">		p-&gt;next = q-&gt;next;</span><br><span class="line">		q-&gt;next = p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateLinkedListByTail</span><span class="params">(LP&amp; L, <span class="type">int</span>* Arr, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LP q = L; <span class="comment">//尾插法构建链表</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		LP p = <span class="keyword">new</span> LL;</span><br><span class="line">		p-&gt;data = Arr[i];</span><br><span class="line">		p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		q-&gt;next = p;</span><br><span class="line">		q = p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="不带头节点链表："><a href="#不带头节点链表：" class="headerlink" title="不带头节点链表："></a>不带头节点链表：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> data;			<span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LNode</span>* next; <span class="comment">//指针指向下一个节点</span></span><br><span class="line">&#125;LNode, * LL;   <span class="comment">//LinkList等价于LNode *,前者强调链表，后者强调结点</span></span><br><span class="line"><span class="comment">//初始化一个空的单链表</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LL&amp; L)</span> </span>&#123;</span><br><span class="line">	L = <span class="literal">NULL</span>;  <span class="comment">//空表</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断单链表是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LL L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (L == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求表的长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(LL L)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	LNode* p = L;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		len++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按位序插入（不带头结点）类似于栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(LL&amp; L, <span class="type">int</span> i, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">1</span>) &#123;		<span class="comment">//插入第一个结点的操作与其他结点不同,因为是不带头节点</span></span><br><span class="line">		LL s = <span class="keyword">new</span> LNode;</span><br><span class="line">		s-&gt;data = e;</span><br><span class="line">		s-&gt;next = L;</span><br><span class="line">		L = s;		<span class="comment">//头指针指向新结点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//第一个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	LL p;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LL s =<span class="keyword">new</span> LNode;</span><br><span class="line">	s-&gt;data = e;</span><br><span class="line">	s-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = s;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按位序删除（不带头结点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(LL&amp; L, <span class="type">int</span> i, <span class="type">int</span>&amp; e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">		LNode* r;</span><br><span class="line">		r = L;</span><br><span class="line">		e = r-&gt;data;</span><br><span class="line">		L = r-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(r);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LL p;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>)	<span class="comment">//第i-1个结点之后已无结点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	LL q = p-&gt;next;</span><br><span class="line">	e = q-&gt;data;</span><br><span class="line">	p-&gt;next = q-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定结点后插操作</span></span><br><span class="line"><span class="comment">//bool InsertNextNode(LNode* p, int e) &#123;</span></span><br><span class="line"><span class="comment">//	if (p == NULL)</span></span><br><span class="line"><span class="comment">//		return false;</span></span><br><span class="line"><span class="comment">//	LNode* s = (LNode*)malloc(sizeof(LNode));</span></span><br><span class="line"><span class="comment">//	if (s == NULL)	//内存分配失败</span></span><br><span class="line"><span class="comment">//		return false;</span></span><br><span class="line"><span class="comment">//	s-&gt;data = e;</span></span><br><span class="line"><span class="comment">//	s-&gt;next = p-&gt;next;</span></span><br><span class="line"><span class="comment">//	p-&gt;next = s;</span></span><br><span class="line"><span class="comment">//	return true;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">////指定节点前插操作</span></span><br><span class="line"><span class="comment">//bool InsertPriorNode(LNode* p, int e) &#123;</span></span><br><span class="line"><span class="comment">//	if (p == NULL)</span></span><br><span class="line"><span class="comment">//		return false;</span></span><br><span class="line"><span class="comment">//	LNode* s = (LNode*)malloc(sizeof(LNode));</span></span><br><span class="line"><span class="comment">//	if (s == NULL)</span></span><br><span class="line"><span class="comment">//		return false;</span></span><br><span class="line"><span class="comment">//	s-&gt;next = p-&gt;next;</span></span><br><span class="line"><span class="comment">//	p-&gt;next = s;		//新结点s连到p之后</span></span><br><span class="line"><span class="comment">//	s-&gt;data = p-&gt;data;  //将p中元素复制到s中</span></span><br><span class="line"><span class="comment">//	p-&gt;data = e;		//将p中元素覆盖为e</span></span><br><span class="line"><span class="comment">//	return true;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="分析题：带头双向链表（按升序由小到大排序）"><a href="#分析题：带头双向链表（按升序由小到大排序）" class="headerlink" title="分析题：带头双向链表（按升序由小到大排序）"></a>分析题：带头双向链表（按升序由小到大排序）</h5><p>单向链表中结点中只存在一个指示直接后继的指针域，所以从某个结点出发只能顺指针向后查找其他节点。</p>
<p>双向链表拥有两个指针域，其一指向直接后继，另一个指向直接前驱。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// 双向循环链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> LTDataType;</span><br><span class="line"><span class="comment">// 定义链表的节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">	LTDataType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ListNode</span>* prev;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ListNode</span>* next;</span><br><span class="line">&#125;LTNode,*LTpoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向链表的头节点创建</span></span><br><span class="line"><span class="function">LTpoint <span class="title">ListCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//LTpoint head = (LTNode*)malloc(sizeof(LTNode));</span></span><br><span class="line">	LTpoint head = <span class="keyword">new</span> LTNode;</span><br><span class="line">	head-&gt;next = head;</span><br><span class="line">	head-&gt;prev = head;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这两个函数是循环双向链表的插法</span></span><br><span class="line"><span class="comment">// 双向链表尾插</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListPushBack</span><span class="params">(LTNode* pHead, LTDataType x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(pHead);</span><br><span class="line">	<span class="comment">//LTNode* newnode = (LTNode*)malloc(sizeof(LTNode)); // 创建的新节点</span></span><br><span class="line">	LTpoint newnode = <span class="keyword">new</span> LTNode;</span><br><span class="line">	newnode-&gt;data = x;</span><br><span class="line">	<span class="comment">// 将新节点插入到链表中</span></span><br><span class="line">	LTNode* prev = pHead-&gt;prev;</span><br><span class="line">	prev-&gt;next = newnode;</span><br><span class="line">	newnode-&gt;prev = prev;</span><br><span class="line">	newnode-&gt;next = pHead;</span><br><span class="line">	pHead-&gt;prev = newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//双向链表打印</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListPrint</span><span class="params">(LTNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(pHead);</span><br><span class="line">	LTNode* tail = pHead-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (tail != pHead) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, tail-&gt;data);</span><br><span class="line">		tail = tail-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在main函数中是这样使用的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LTpoint head = <span class="built_in">ListCreate</span>();</span><br><span class="line">	<span class="comment">//方法1，在输入数据的时候就对数据进行排序</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;输入创建链表的长度&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">1001</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> temp;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;个数据&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; temp;</span><br><span class="line">		arr[i] = temp;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &gt; arr[j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> t = arr[i];</span><br><span class="line">				arr[i] = arr[j];</span><br><span class="line">				arr[j] = t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ListPushBack</span>(head, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">ListPrint</span>(head);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="编程题：带头循环单链表（将数据从小到大排列，去除重复数据）"><a href="#编程题：带头循环单链表（将数据从小到大排列，去除重复数据）" class="headerlink" title="编程题：带头循环单链表（将数据从小到大排列，去除重复数据）"></a>编程题：带头循环单链表（将数据从小到大排列，去除重复数据）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125; CLRN, * CLRP;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T* a, T* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *b;</span><br><span class="line">    *b = *a;</span><br><span class="line">    *a = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partPos</span><span class="params">(<span class="type">long</span> <span class="type">long</span>  arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = high;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[++i] &lt; pivot);</span><br><span class="line">        <span class="keyword">while</span> (arr[--j] &gt; pivot);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(&amp;arr[i], &amp;arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">swap</span>(&amp;arr[i], &amp;arr[high]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qsort</span><span class="params">(<span class="type">long</span> <span class="type">long</span>  arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = <span class="built_in">partPos</span>(arr, low, high);</span><br><span class="line">        <span class="built_in">Qsort</span>(arr, low, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Qsort</span>(arr, mid + <span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">long</span> <span class="type">long</span>  arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Qsort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(<span class="type">long</span> <span class="type">long</span>  arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, arr + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">CLRP <span class="title">CreateList</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLRP head;</span><br><span class="line">    head = <span class="keyword">new</span> CLRN;</span><br><span class="line">    CLRP q = head;</span><br><span class="line">    elemtype x;</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> * arr = <span class="keyword">new</span> <span class="type">long</span> <span class="type">long</span> [i];<span class="comment">//构建动态数组</span></span><br><span class="line">    q = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">/* CLRP p = new CLRN;</span></span><br><span class="line"><span class="comment">        cin &gt;&gt; p-&gt;data;</span></span><br><span class="line"><span class="comment">        p-&gt;next = NULL;</span></span><br><span class="line"><span class="comment">        if (q != NULL)</span></span><br><span class="line"><span class="comment">            q-&gt;next = p;</span></span><br><span class="line"><span class="comment">        q = p;*/</span></span><br><span class="line">        cin &gt;&gt; arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr,i);<span class="comment">//快排，dddd，不懂就去用其他排序方式捏</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] != arr[j + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            CLRP p = <span class="keyword">new</span> CLRN;</span><br><span class="line">            p-&gt;data = arr[j];</span><br><span class="line">            <span class="comment">//尾插法</span></span><br><span class="line">            q-&gt;next = p;</span><br><span class="line">            q = p;</span><br><span class="line">            q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">//头插法</span></span><br><span class="line">            <span class="comment">/*p-&gt;next = q-&gt;next;</span></span><br><span class="line"><span class="comment">            q-&gt;next = p;*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateCircle</span><span class="params">(CLRP&amp; rear, CLRP&amp; head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLRP p= head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    rear = p;</span><br><span class="line">    rear-&gt;next = head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printLis</span><span class="params">(CLRP Head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLRP p = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLRP rear=<span class="keyword">new</span> CLRN;</span><br><span class="line">    CLRP head;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; i;</span><br><span class="line">    head = <span class="built_in">CreateList</span>(i);<span class="comment">//构建带头循环单链表</span></span><br><span class="line">    <span class="built_in">CreateCircle</span>(rear, head);</span><br><span class="line">    <span class="built_in">printLis</span>(head);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二 在每次插入数据的过程中都对链表进行一次遍历，并根据结点中的数据域来判断新结点所插入的位置或者是否插入。</span></span><br><span class="line"><span class="comment">//分为 p.data&gt;data p.data&lt;data p.data=data 三种情况来判断</span></span><br><span class="line"><span class="comment">//但当链表已经是有序时选择插入的位置可以使用更快的查找方式来寻找。</span></span><br></pre></td></tr></table></figure>



<h2 id="二、栈"><a href="#二、栈" class="headerlink" title="二、栈"></a>二、栈</h2><p>栈的主要考点为递归，需要了解什么是递归，会使用简单的DFS算法</p>
<h4 id="栈的构建"><a href="#栈的构建" class="headerlink" title="栈的构建"></a>栈的构建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    LNode* next;</span><br><span class="line">&#125;LNode, * List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    List bottom;</span><br><span class="line">    List top;</span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initStack</span><span class="params">(Stack&amp; S)</span> </span>&#123;</span><br><span class="line">    S.bottom = <span class="keyword">new</span> LNode;</span><br><span class="line">    S.top = S.bottom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">(Stack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.bottom == S.top) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(Stack&amp; S, ElemType e)</span></span>&#123;</span><br><span class="line">    List node = <span class="keyword">new</span> LNode;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = S.top;</span><br><span class="line">    S.top = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(Stack&amp; S, ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">empty</span>(S)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;栈为空，不能弹出元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        e = S.top-&gt;data;</span><br><span class="line">        List p = S.top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> S.top;</span><br><span class="line">        S.top = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getTop</span><span class="params">(Stack S, ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">empty</span>(S)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;栈为空,没有栈顶元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    <span class="built_in">initStack</span>(s);</span><br><span class="line">    <span class="built_in">push</span>(s, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">push</span>(s, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">push</span>(s, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">push</span>(s, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">push</span>(s, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">push</span>(s, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="built_in">pop</span>(s, num);</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DFS算法"><a href="#DFS算法" class="headerlink" title="DFS算法"></a>DFS算法</h4><p>DFS的体现主要在二叉树的前、中、后序遍历和图上，后面会进行解释。</p>
<h2 id="三、队列"><a href="#三、队列" class="headerlink" title="三、队列"></a>三、队列</h2><h4 id="链式存储队列"><a href="#链式存储队列" class="headerlink" title="链式存储队列"></a>链式存储队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*     链式队列是对链表进行封装，包含一个对头指针和一个队尾指针</span></span><br><span class="line"><span class="comment">*     使用对头指针进行出队，使用队尾指针进行入队</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    LNode* next;</span><br><span class="line">&#125;LNode, * List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    List rear;</span><br><span class="line">    List front;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*      初始化与链表类似，先让对头指针指向新开辟的空间</span></span><br><span class="line"><span class="comment">*      然后让队尾指针=对头指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initQueue</span><span class="params">(Queue&amp; S)</span> </span>&#123;</span><br><span class="line">    S.rear = <span class="keyword">new</span> LNode;</span><br><span class="line">    S.front = S.rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">(Queue S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过头尾是否重合来判空</span></span><br><span class="line">    <span class="keyword">if</span> (S.rear == S.front) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">*      队列是一种先进先出的结构，对此我们采用尾插法</span></span><br><span class="line"><span class="comment">*      1) 先新开辟一个node节点，对其进行赋值</span></span><br><span class="line"><span class="comment">*      2) 然后让队尾指针指向该节点</span></span><br><span class="line"><span class="comment">*      3) 更新队尾指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(Queue&amp; S, ElemType e)</span></span>&#123;</span><br><span class="line">    List node = <span class="keyword">new</span> LNode;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    S.rear-&gt;next = node;</span><br><span class="line">    S.rear = S.rear-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">*      在弹出队列中元素时，我们需要先进行判空，如果不为空再进行操作</span></span><br><span class="line"><span class="comment">*      步骤如下：</span></span><br><span class="line"><span class="comment">*      1) 先让一个指针保存队头指针的下一个节点</span></span><br><span class="line"><span class="comment">*      2) 因为存在头节点，第一个元素保存再队头指针的下一个节点，所以 e = p-&gt;data</span></span><br><span class="line"><span class="comment">*      3) 删除当前头节点指向的那个空间，最后更新对头指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(Queue&amp; S, ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">empty</span>(S)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;队列为空，不能弹出元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        List p = S.front-&gt;next;</span><br><span class="line">        e = p-&gt;data;</span><br><span class="line">        <span class="keyword">delete</span> S.front;</span><br><span class="line">        S.front = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getfront</span><span class="params">(Queue S, ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">empty</span>(S)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;队列为空,没有栈顶元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    <span class="built_in">initQueue</span>(q);</span><br><span class="line">    <span class="built_in">push</span>(q, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">push</span>(q, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">push</span>(q, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">push</span>(q, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">push</span>(q, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">push</span>(q, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>(q)) &#123;</span><br><span class="line">            <span class="type">int</span> num;</span><br><span class="line">            <span class="built_in">pop</span>(q, num);</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//此时虽然MAXSIAE为10但是实际能够存储元素的个数为9，空出来的一个用来判断队列是否满</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">*		循环队列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line">	<span class="type">int</span> front;</span><br><span class="line">	<span class="type">int</span> rear;</span><br><span class="line">	ElemType data[MAXSIZE];</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//	在初始化时，需要将头尾指针同时指向0号位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initQueue</span><span class="params">(Queue&amp; Q)</span> </span>&#123;</span><br><span class="line">	Q.front = <span class="number">0</span>;</span><br><span class="line">	Q.rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">(Queue Q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.rear == Q.front) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(Queue&amp; Q,ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断为满的情况，即：队尾+1 然后取模</span></span><br><span class="line">	<span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MAXSIZE == Q.front) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;队列元素已经存满&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		Q.data[Q.rear] = e;</span><br><span class="line">		Q.rear = (Q.rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(Queue&amp; Q, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.front == Q.rear) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;队列里什么都没有&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		e = Q.data[Q.front];</span><br><span class="line">		Q.front = (Q.front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//	获取长度 公式为：(Q.rear - Q.front + MAXSIZE) % MAXSIZE</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getLenght</span><span class="params">(Queue &amp;Q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (Q.rear - Q.front + MAXSIZE) % MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	TEST</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Queue q;</span><br><span class="line">	<span class="built_in">initQueue</span>(q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">push</span>(q, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">getLenght</span>(q) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">int</span> a;</span><br><span class="line">			<span class="built_in">pop</span>(q, a);</span><br><span class="line">			cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、数组和广义表"><a href="#四、数组和广义表" class="headerlink" title="四、数组和广义表"></a>四、数组和广义表</h2><h4 id="数组的行优先与列优先"><a href="#数组的行优先与列优先" class="headerlink" title="数组的行优先与列优先"></a>数组的行优先与列优先</h4><p>例一：</p>
<p>假设以行序为主序存储二维数组$A[100][100]$，设每个数据元素占2个存储单元，基地址为10，则$A[5][5]$的存储地址为(1020）。</p>
<p>答：以行序为主，则有： $[(5*100)+5]*2+10&#x3D;1020$。</p>
<p>例二：</p>
<p>若A是按列为主序进行存储的4x6的二维数组，其每个元素占用3个存储单元，并且$A[0][0]$的存储地址为1000，元素$A[1][3]$的存储地址为(1039),该数组共占用(72)个存储单元。</p>
<h4 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h4><p>主要注意Head()函数和Tail()函数。</p>
<p>例题：</p>
<p>广义表 A &#x3D; (a,b,(c,d),(e,(f,g))) ，则 Head(Tail(Head(Tail(Tail(A))))) 的值为（ d）。</p>
<p>答：Tail(A) &#x3D; (b,(c,d),(e,(f,g)))；Tail(Tail(A)) &#x3D; ( (c,d),(e,(f,g)))； Head(Tail(Tail(A))) &#x3D;  (c,d)；Tail(Head(Tail(Tail(A)))) &#x3D; (d)；Head(Tail(Head(Tail(Tail(A))))) &#x3D; d。</p>
<h2 id="五、串"><a href="#五、串" class="headerlink" title="五、串"></a>五、串</h2><h4 id="1-BF-暴力匹配"><a href="#1-BF-暴力匹配" class="headerlink" title="1.BF(暴力匹配)"></a>1.BF(暴力匹配)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *     s作为主串，t作为模式串进行匹配</span></span><br><span class="line"><span class="comment"> *     使用暴力匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Baoli</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//i和j分别作为指针</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ls = s.<span class="built_in">length</span>();</span><br><span class="line">	<span class="type">int</span> lt = t.<span class="built_in">length</span>();</span><br><span class="line">	<span class="keyword">while</span> (i &lt; ls &amp;&amp; j &lt; lt) &#123;</span><br><span class="line">        <span class="comment">//如果相等则各自++，然后进行下一次的比较</span></span><br><span class="line">		<span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//反之不相等，i就需要回退到开始匹配的下一个位置，即：i - j + 1 。j退回为0</span></span><br><span class="line">        <span class="comment">// ！！！注意如果你的字符串是从1号位置开始，要改为：i = i - j + 2;j = 1;</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			i = i - j + <span class="number">1</span>;</span><br><span class="line">			j = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//while循环结束后，如果j已经到达模式串的最后一位说明已经比较到头，且找到了子串，返回第一次出现的位置即可</span></span><br><span class="line">	<span class="keyword">if</span> (j == lt) &#123;</span><br><span class="line">		<span class="keyword">return</span> i - j;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//反之，就是i已经循环到头，且j没有到头，此时没有找到子串，返回-1。</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s = <span class="string">&quot;abcabcasd&quot;</span>;</span><br><span class="line">	string t = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">Baoli</span>(s, t) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-KMP匹配"><a href="#2-KMP匹配" class="headerlink" title="2.KMP匹配"></a>2.KMP匹配</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> Next[<span class="number">999</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ls = s.<span class="built_in">length</span>();</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">	Next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; ls<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || s[k] == s[j]) &#123;</span><br><span class="line">			k++;</span><br><span class="line">			j++;</span><br><span class="line">			Next[j] = k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			k = Next[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">getNext</span>(t);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ls = s.<span class="built_in">length</span>(), lt = t.<span class="built_in">length</span>();</span><br><span class="line">	<span class="keyword">while</span> (i &lt; ls &amp;&amp; j &lt; lt) &#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == t[j]) &#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			j = Next[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j == lt) &#123;</span><br><span class="line">		<span class="keyword">return</span> i - j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s = <span class="string">&quot;ababcdf&quot;</span>;</span><br><span class="line">	string t = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">kmp</span>(s,t) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-删除串中相同的元素"><a href="#3-删除串中相同的元素" class="headerlink" title="3.删除串中相同的元素"></a>3.删除串中相同的元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(String&amp; L)</span> </span>&#123;</span><br><span class="line">    String p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        String t = p-&gt;next;</span><br><span class="line">        String <span class="type">pre_t</span> = p;</span><br><span class="line">        <span class="keyword">while</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;data == t-&gt;data) &#123;</span><br><span class="line">                <span class="type">pre_t</span>-&gt;next = t-&gt;next;</span><br><span class="line">                <span class="built_in">delete</span>(t);</span><br><span class="line">                t = <span class="type">pre_t</span>-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">pre_t</span> = t;</span><br><span class="line">                t = t-&gt;next;</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="六、树"><a href="#六、树" class="headerlink" title="六、树"></a>六、树</h2><h2 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1.基本定义"></a>1.基本定义</h2><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>树是n(n&gt;&#x3D;0)个结点的有限集T，T为空时称为空树，否则它满足如下两个条件：</p>
<ol>
<li>有且仅有一个特定的称为根的结点；</li>
<li>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1,T2,T3…Tm，其中每个子集又是一棵树，并称其为根的子树。</li>
</ol>
<p><strong>其他一些重要概念</strong></p>
<ul>
<li>结点——表示树中的元素，包括数据项及若干指向其子树的分支。</li>
<li>结点的度(degree)——结点拥有的子树数。</li>
<li>叶子(leaf)——度为0的结点。</li>
<li>孩子(child)——结点子树的根称为该结点的孩子。</li>
<li>双亲(parents)——孩子结点的上层结点叫该结点的双亲。</li>
<li>兄弟(sibling)——同一双亲的孩子。</li>
<li>树的度——一棵树中最大的结点度数。</li>
<li>结点的层次(level)——从根结点算起，根为第一层，它的孩子为第二层……</li>
<li>深度(depth)——树中结点的最大层次数。</li>
<li>森林(forest)——m(m³0)棵互不相交的树的集合。</li>
</ul>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树是由n(n&gt;&#x3D;0)个结点的有限集合构成，此集合或者为空集，或者由一个根结点及两棵互不相交的左右子树组成，并且左右子树都是二叉树。</p>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>一棵深度为k且由 2k-1个结点的二叉树称为满二叉树。简单来说就是不存在度为<code>1</code>的点。</p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>如果深度为k、由n个结点的二叉树中每个结点能够与深度为k的顺序编号的满二叉树从1到n标号的结点相对应，则称这样的二叉树为完全二叉树。</p>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>又称最优二叉树，给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树。</p>
<h2 id="2-二叉树的创建和遍历"><a href="#2-二叉树的创建和遍历" class="headerlink" title="2.二叉树的创建和遍历"></a>2.二叉树的创建和遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    Node* lchild;</span><br><span class="line">    Node* rchild;</span><br><span class="line">&#125;TreeNode,*BiTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span> </span>&#123;</span><br><span class="line">    ElemType e;</span><br><span class="line">    cin &gt;&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        T = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        T-&gt;data = e;</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preTraversal</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">preTraversal</span>(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">preTraversal</span>(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">midTraversal</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">midTraversal</span>(T-&gt;lchild);</span><br><span class="line">    cout &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">midTraversal</span>(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postTraversal</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">postTraversal</span>(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">postTraversal</span>(T-&gt;rchild);</span><br><span class="line">    cout &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelTraversal</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;BiTree&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">empty</span>(q)) &#123;</span><br><span class="line">        BiTree temp = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; temp-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(temp-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(temp-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    <span class="comment">/*      例如输入：ABDE##F###CG##H## </span></span><br><span class="line"><span class="comment">    *       我们得到的二叉树是这样的：</span></span><br><span class="line"><span class="comment">    *                       A</span></span><br><span class="line"><span class="comment">    *                      / \</span></span><br><span class="line"><span class="comment">    *                     B   C</span></span><br><span class="line"><span class="comment">    *                    /   / \</span></span><br><span class="line"><span class="comment">    *                   D   G   H</span></span><br><span class="line"><span class="comment">    *                  / \</span></span><br><span class="line"><span class="comment">    *                 E   F</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">CreateBiTree</span>(T);</span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;preTraversal&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">preTraversal</span>(T);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;midTraversal&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">midTraversal</span>(T);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;postTraversal&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">postTraversal</span>(T);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//层次遍历</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;levelTraversal&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">levelTraversal</span>(T);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-二叉树的相关题目"><a href="#3-二叉树的相关题目" class="headerlink" title="3.二叉树的相关题目"></a>3.二叉树的相关题目</h2><h4 id="1-给定前-后-遍历顺序和中序遍历，求二叉树的形态"><a href="#1-给定前-后-遍历顺序和中序遍历，求二叉树的形态" class="headerlink" title="(1)给定前(后)遍历顺序和中序遍历，求二叉树的形态"></a>(1)给定前(后)遍历顺序和中序遍历，求二叉树的形态</h4><h5 id="方法一：递归模拟"><a href="#方法一：递归模拟" class="headerlink" title="方法一：递归模拟"></a>方法一：递归模拟</h5><ul>
<li>首先根据前或后序遍历的结果确定，根节点的标号。</li>
<li>然后在中序遍历中，把根节点左边的化为左子树，右边的化为右子树</li>
<li>重复上面的过程</li>
</ul>
<h5 id="方法二：矩阵暴力"><a href="#方法二：矩阵暴力" class="headerlink" title="方法二：矩阵暴力"></a>方法二：矩阵暴力</h5><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Xu411d7qf?share_source=copy_web">参考视频</a></p>
<ul>
<li>根据先序或后序遍历从上到下创建y轴，如果是先序就从左往右，如果是后序就从右往左。</li>
<li>然后根据中序遍历从左往右做出x轴。</li>
<li>在图中标出对应的点。</li>
<li>从最上方的根节点开始连接相邻的点。</li>
</ul>
<h4 id="2-求度为0、1、2的节点个数"><a href="#2-求度为0、1、2的节点个数" class="headerlink" title="(2)求度为0、1、2的节点个数"></a>(2)求度为0、1、2的节点个数</h4><p>为了方便，我们令$ n_0 $为度为0的节点的个数，令$ n_1 $为度为1的节点的个数，令$n_2$为度为2的节点的个数。且设<code>S</code>为总的节点个数。</p>
<p>从节点个数出发，我们能够得到：$n_0+n_1+n_2&#x3D;S$</p>
<p>从边数出发，我们能得到：$n_1+2*n_2+1&#x3D;S$</p>
<p>就此能推出：$n_2+1&#x3D;n_1$</p>
<p>基本上所有的题目的核心就是上面这个公式，记住这个很多问题可以迎刃而解。</p>
<h2 id="4-哈夫曼树"><a href="#4-哈夫曼树" class="headerlink" title="4.哈夫曼树"></a>4.哈夫曼树</h2><h4 id="哈夫曼的编码与解码"><a href="#哈夫曼的编码与解码" class="headerlink" title="哈夫曼的编码与解码"></a>哈夫曼的编码与解码</h4><p>核心是每次找到最小的两个点将其合并，然后继续比较，知道所有的点全部被纳入。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> index[<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HFM</span>&#123;</span><br><span class="line">	<span class="type">int</span> weight=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> parent=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> lchild=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> rchild=<span class="number">0</span>;</span><br><span class="line">&#125;a[<span class="number">9999</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitHfm</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i].weight;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每次寻找到最小的两个数，然后标记</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindMinTwoMun</span><span class="params">(<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> weight1=<span class="number">999</span>,weight2=<span class="number">999</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=end;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i].parent == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i].weight&lt;weight2)&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i].weight&lt;weight1)&#123;</span><br><span class="line">					weight2=weight1;</span><br><span class="line">					weight1=a[i].weight;</span><br><span class="line">					index[<span class="number">1</span>]=index[<span class="number">0</span>];</span><br><span class="line">					index[<span class="number">0</span>]=i;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					weight2=a[i].weight;</span><br><span class="line">					index[<span class="number">1</span>]=i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把最小的两个数合并，然后把合并后的添加到数组中继续比较</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findwhat</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">+1</span>;i&lt;=<span class="number">2</span>*n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">FindMinTwoMun</span>(i<span class="number">-1</span>);</span><br><span class="line">		a[i].weight=a[index[<span class="number">0</span>]].weight+a[index[<span class="number">1</span>]].weight;</span><br><span class="line">		a[index[<span class="number">0</span>]].parent=i;</span><br><span class="line">		a[index[<span class="number">1</span>]].parent=i;</span><br><span class="line">		a[i].lchild=index[<span class="number">0</span>];</span><br><span class="line">		a[i].rchild=index[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对每个点判断，知道parent==0时截止，如果是左子树则push(1)，不然是push(0),最后弹出即可</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HfmCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> k=i;</span><br><span class="line">		<span class="keyword">while</span>(a[k].parent!=<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="type">int</span> next=a[k].parent;</span><br><span class="line">			<span class="keyword">if</span>(a[next].lchild==k)&#123;</span><br><span class="line">				st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				st.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			k=next;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;a[i].weight&lt;&lt;<span class="string">&quot;hfm code:&quot;</span>;</span><br><span class="line">		<span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			cout&lt;&lt;st.<span class="built_in">top</span>();</span><br><span class="line">			st.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintHfm</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		cout&lt;&lt;a[i].weight&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a[i].parent&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a[i].lchild&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a[i].rchild&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">InitHfm</span>();</span><br><span class="line">	<span class="built_in">findwhat</span>();</span><br><span class="line">	<span class="built_in">PrintHfm</span>();</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">HfmCode</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>设哈夫曼树中有199个结点，则该哈夫曼树中有（<em>100</em>）个叶子结点。</p>
<p>在哈夫曼树中没有度为1的结点，只有度为0（叶子结点）和度为2的结点。设叶子结点的个数为n0，度为2的结点的个数为n2，由二叉树的性质n0&#x3D;n2+1，则总结点数n&#x3D; n0+n2&#x3D;2*n0-1，得到n0&#x3D;100。</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="七、图"><a href="#七、图" class="headerlink" title="七、图"></a>七、图</h2><h4 id="图的领接表版本的Dijkstra"><a href="#图的领接表版本的Dijkstra" class="headerlink" title="图的领接表版本的Dijkstra"></a>图的领接表版本的Dijkstra</h4><p>迪杰斯特拉算法采用的是一种贪心的策略。</p>
<p>求源点到其余各点的最短距离步骤如下：</p>
<p>用一个 dist 数组保存源点到其余各个节点的距离，dist[i] 表示源点到节点 i 的距离。初始时，dist 数组的各个元素为无穷大。<br>用一个状态数组 state 记录是否找到了源点到该节点的最短距离，state[i] 如果为真，则表示找到了源点到节点 i 的最短距离，state[i] 如果为假，则表示源点到节点 i 的最短距离还没有找到。初始时，state 各个元素为假。<img src="https://cdn.acwing.com/media/article/image/2021/03/04/55289_0783d4c47c-03.png" alt="03.png"></p>
<p>源点到源点的距离为 0。即dist[1] &#x3D; 0。<img src="https://cdn.acwing.com/media/article/image/2021/03/04/55289_4afe05d47c-04.png" alt="04.png"></p>
<p>遍历 dist 数组，找到一个节点，这个节点是：没有确定最短路径的节点中距离源点最近的点。假设该节点编号为 i。此时就找到了源点到该节点的最短距离，state[i] 置为 1。<img src="https://cdn.acwing.com/media/article/image/2021/03/04/55289_5338a3607c-05.png" alt="05.png"></p>
<p>遍历 i 所有可以到达的节点 j，如果 dist[j] 大于 dist[i] 加上 i -&gt; j 的距离，即 dist[j] &gt; dist[i] + w[i][j]（w[i][j] 为 i -&gt; j 的距离） ，则更新 dist[j] &#x3D; dist[i] + w[i][j]。<img src="https://cdn.acwing.com/media/article/image/2021/03/04/55289_58bec3b67c-06.png" alt="06.png"></p>
<p>重复 3 4 步骤，直到所有节点的状态都被置为 1。<img src="https://cdn.acwing.com/media/article/image/2021/03/04/55289_5fcd522c7c-071.png" alt="071.png"></p>
<p>此时 dist 数组中，就保存了源点到其余各个节点的最短距离。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXINT  655333</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//用邻接表存储图    有向网！！！</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum  100<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;<span class="comment">//顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span><span class="comment">//边结点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;<span class="comment">//与该边结点相邻的结点(即所属的表头结点)在图中的位置,即数组下标</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> * nextarc;<span class="comment">//   指向与表头结点邻接的下一条边的指针</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span><span class="comment">//顶点信息,即表头结点</span></span><br><span class="line">&#123;</span><br><span class="line">    VerTexType name;<span class="comment">//表头顶点的名字</span></span><br><span class="line">    ArcNode *firstarc;<span class="comment">//指向第一条依附该顶点的边的指针</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//表头结点组成一个AdjList类型的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    AdjList vertices;<span class="comment">//表头数组</span></span><br><span class="line">    <span class="type">int</span> vexnum;<span class="comment">//图当前的顶点数</span></span><br><span class="line">    <span class="type">int</span> arcnum;<span class="comment">//图当前的边数</span></span><br><span class="line">&#125;ALGraph;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>  Status;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1;</span></span><br><span class="line"><span class="comment">//在邻接表G中找顶点名为v1的下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateVex</span><span class="params">(ALGraph &amp;G,VerTexType v1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历顶点表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(G.vertices[i].name==v1)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建有向图的邻接表</span></span><br><span class="line"><span class="function">Status <span class="title">CreateALGraph</span><span class="params">(ALGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入图的顶点总数和边总数：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入各顶点的名字：(顶点的名字必须为char型)&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;G.vertices[i].name;</span><br><span class="line">        <span class="comment">//初始化表头结点的指针域为NULL</span></span><br><span class="line">        G.vertices[i].firstarc=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//初始化完成，输入各边，构造邻接表</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入每条边所邻接了的两个顶点的名字与权值：(顺序：v1-&gt;v2)&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;G.arcnum;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> v1,v2;</span><br><span class="line">        cin&gt;&gt;v1&gt;&gt;v2;</span><br><span class="line">        <span class="comment">//依据名字找顶点的数组下标</span></span><br><span class="line">        <span class="type">int</span> i=<span class="built_in">LocateVex</span>(G,v1);</span><br><span class="line">        <span class="type">int</span> j=<span class="built_in">LocateVex</span>(G,v2);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//生成一个新的边结点*p1</span></span><br><span class="line">        ArcNode *p1=<span class="keyword">new</span> ArcNode;</span><br><span class="line">        <span class="comment">//输入边的权值：</span></span><br><span class="line">        cin&gt;&gt;p1-&gt;weight;</span><br><span class="line">        p1-&gt;adjvex=j;</span><br><span class="line">        p1-&gt;nextarc=G.vertices[i].firstarc;</span><br><span class="line">        G.vertices[i].firstarc=p1;</span><br><span class="line">        <span class="comment">//将新结点*p1插入顶点vi的边表头部</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //输出邻接矩阵，检查</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;G.vexnum;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;G.vexnum;j++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;G.arcs[i][j]&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//迪杰斯特拉算法求最短路径：(有向网G，初始顶点v0)</span></span><br><span class="line"><span class="comment">//初始顶点给的是名字！要先找出其下标！</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShortestPath_AL</span><span class="params">(ALGraph G,VerTexType v0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找名字所属的下标：</span></span><br><span class="line">    <span class="type">int</span> v00= <span class="built_in">LocateVex</span>(G,v0);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//网的结点个数：</span></span><br><span class="line">    <span class="type">int</span> n=G.vexnum;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//辅助数据结构：</span></span><br><span class="line">    <span class="comment">//一维数组S[i]:记录从源点v0到终点vi是否已被确定最短路径</span></span><br><span class="line">    <span class="type">int</span>  S[MVNum]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//记录从源点v0到终点vi的当前最短路径上vi的直接前驱顶点序号</span></span><br><span class="line">    <span class="type">int</span> Path[MVNum];</span><br><span class="line">    <span class="comment">//记录从源点v0到终点vi的当前最短路径长度；初值为：如果</span></span><br><span class="line">    <span class="type">int</span> D[MVNum];</span><br><span class="line">    <span class="comment">//初始化辅助数组：</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;n;v++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//全部初始化为0，即初始时，全部都未确定最短路径</span></span><br><span class="line">        S[v]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //初始化D[v]为v00到各个终点v的权值：难点！</span></span><br><span class="line"><span class="comment">        //两层循环找！</span></span><br><span class="line"><span class="comment">        //相当于指针从头到尾遍历一遍，看是否存在与第0个结点邻接</span></span><br><span class="line"><span class="comment">               //再从头到尾遍历一遍，看是否存在与第1个结点邻接</span></span><br><span class="line"><span class="comment">                          //找到即操作，没找到就下一个</span></span><br><span class="line"><span class="comment">               //再从头到尾遍历一遍，看是否存在与第2个结点邻接...</span></span><br><span class="line"><span class="comment">                          //找到即操作，没找到就下一个</span></span><br><span class="line"><span class="comment">        // 1.确定了终点v，在终点v的情况下找v00的链表，</span></span><br><span class="line"><span class="comment">        // 2.如果v00的链表中有下标为v的，即表明有边链接，则置D[v]为权值，结束循环</span></span><br><span class="line"><span class="comment">        // 3.否则，置D[v]为无穷！</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//指针先指向v00的第一条邻接边：</span></span><br><span class="line">        ArcNode *p=G.vertices[v00].firstarc;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//何时停止-&gt;指针指向空的时候</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;p!=<span class="literal">NULL</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//v00与v之间有边链接</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;adjvex==v)</span><br><span class="line">            &#123;</span><br><span class="line">                D[v]=p-&gt;weight;</span><br><span class="line">                <span class="comment">//v的前驱为v00</span></span><br><span class="line">                Path[v]=v00;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//p指向下一条邻接边</span></span><br><span class="line">            p=p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指针指向空：即v00与v没有邻接，则权值置为无穷大</span></span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            D[v]=MAXINT;</span><br><span class="line">            Path[v]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//v00点最短路径已确定</span></span><br><span class="line">    S[v00]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//v00-&gt;v00最短路径0</span></span><br><span class="line">    D[v00]=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//===初始化结束开始主循环，每次求得v00到某个顶点v的最短路径(共循环n-1次)，将v加到S集===</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> min=MAXINT;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">0</span>;w&lt;n;++w)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找当前点到所有点的最短路径，</span></span><br><span class="line">            <span class="comment">//并将该最短距离所到的点赋值给v，</span></span><br><span class="line">            <span class="comment">//最短的距离赋值给min</span></span><br><span class="line">            <span class="keyword">if</span> (!S[w] &amp;&amp; D[w] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                v = w;</span><br><span class="line">                min = D[w];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将v加入S，标志v的最短路径已经确定</span></span><br><span class="line">        S[v]=<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//更新从v0出发到集合V-S上的所有顶点的最短路径长度  难度！</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">0</span>;w&lt;n;w++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//指针先指向v的第一条邻接边：</span></span><br><span class="line">            ArcNode *pv=G.vertices[v].firstarc;</span><br><span class="line">            <span class="comment">//记录v到剩余未访问过的边的权值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;pv!=<span class="literal">NULL</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//v-&gt;w有边</span></span><br><span class="line">                <span class="keyword">if</span>(pv-&gt;adjvex==w)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//是否更新</span></span><br><span class="line">                    <span class="keyword">if</span>(!S[w]&amp;&amp;(D[v]+pv-&gt;weight&lt;D[w]))</span><br><span class="line">                    &#123;</span><br><span class="line">                        D[w] = D[v] + pv-&gt;weight;</span><br><span class="line">                        Path[w] = v;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//pv指向v的下一条邻接边</span></span><br><span class="line">                pv=pv-&gt;nextarc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(D[i]==MAXINT)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;从&quot;</span>&lt;&lt;v0&lt;&lt;<span class="string">&quot;到&quot;</span>&lt;&lt;G.vertices[i].name&lt;&lt;<span class="string">&quot;结点的最短路径为：不可到达！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;从&quot;</span>&lt;&lt;v0&lt;&lt;<span class="string">&quot;到&quot;</span>&lt;&lt;G.vertices[i].name&lt;&lt;<span class="string">&quot;结点的最短路径为：&quot;</span>&lt;&lt;D[i]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALGraph G;</span><br><span class="line">    <span class="built_in">CreateALGraph</span>(G);</span><br><span class="line"> </span><br><span class="line">    VerTexType qidian;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入起始顶点：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;qidian;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">ShortestPath_AL</span>(G,qidian);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆优化"><a href="#堆优化" class="headerlink" title="堆优化"></a><strong>堆优化</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;<span class="comment">//邻接矩阵存储图</span></span><br><span class="line"><span class="type">int</span> state[N];<span class="comment">//state 记录是否找到了源点到该节点的最短距离</span></span><br><span class="line"><span class="type">int</span> dist[N];<span class="comment">//dist 数组保存源点到其余各个节点的距离</span></span><br><span class="line"><span class="type">int</span> n, m;<span class="comment">//图的节点个数和边数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span><span class="comment">//插入边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));<span class="comment">//dist 数组的各个元素为无穷大</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//源点到源点的距离为置为 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//遍历 dist 数组，找到没有确定最短路径的节点中距离源点最近的点t</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!state[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t]))</span><br><span class="line">                t = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        state[t] = <span class="number">1</span>;<span class="comment">//state[i] 置为 1。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = h[t]; j != <span class="number">-1</span>; j = ne[j])<span class="comment">//遍历 t 所有可以到达的节点 i</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> i = e[j];</span><br><span class="line">            dist[i] = <span class="built_in">min</span>(dist[i], dist[t] + w[j]);<span class="comment">//更新 dist[j]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));<span class="comment">//邻接矩阵初始化</span></span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--)<span class="comment">//读入 m 条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(a, b, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Dijkstra</span>();</span><br><span class="line">    <span class="keyword">if</span> (dist[n] != <span class="number">0x3f3f3f3f</span>)<span class="comment">//如果dist[n]被更新了，则存在路径</span></span><br><span class="line">        cout &lt;&lt; dist[n];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="拓扑排序的过程"><a href="#拓扑排序的过程" class="headerlink" title="拓扑排序的过程"></a><strong>拓扑排序的过程</strong></h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HL411E7TE?from=search&seid=13428176407601856884&spm_id_from=333.337.0.0">过程而已不用上代码吧</a></p>
<p>对一个有向图，适当对有向图编号编号使其对称 变成下三角与上三角</p>
<h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><h5 id="1-Kruskal"><a href="#1-Kruskal" class="headerlink" title="(1)Kruskal"></a>(1)Kruskal</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载小于号</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span> <span class="comment">// 一般来说比较函数写在结构体内会比写在外部快</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将所有边排序</span></span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b; <span class="comment">// 合并两个集合</span></span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ; <span class="comment">// cnt存的是当前加了多少条边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">kruskal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-Prim"><a href="#2-Prim" class="headerlink" title="(2)Prim"></a>(2)Prim</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];<span class="comment">//存储图</span></span><br><span class="line"><span class="type">int</span> dt[N];<span class="comment">//存储各个节点到生成树的距离</span></span><br><span class="line"><span class="type">int</span> st[N];<span class="comment">//节点是否被加入到生成树中</span></span><br><span class="line"><span class="type">int</span> pre[N];<span class="comment">//节点的前去节点</span></span><br><span class="line"><span class="type">int</span> n, m;<span class="comment">//n 个节点，m 条边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dt,<span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dt));<span class="comment">//初始化距离数组为一个很大的数（10亿左右）</span></span><br><span class="line">    <span class="type">int</span> res= <span class="number">0</span>;</span><br><span class="line">    dt[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//从 1 号节点开始生成 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//每次循环选出一个点加入到生成树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//每个节点一次判断</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dt[j] &lt; dt[t]))<span class="comment">//如果没有在树中，且到树的距离最短，则选择该点</span></span><br><span class="line">                t = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="number">1</span>;<span class="comment">// 选择该点</span></span><br><span class="line">        res += dt[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//更新生成树外的点到生成树的距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dt[i] &gt; g[t][i] &amp;&amp; !st[i])<span class="comment">//从 t 到节点 i 的距离小于原来距离，则更新。</span></span><br><span class="line">            &#123;</span><br><span class="line">                dt[i] = g[t][i];<span class="comment">//更新距离</span></span><br><span class="line">                pre[i] = t;<span class="comment">//从 t 到 i 的距离更短，i 的前驱变为 t.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPath</span><span class="params">()</span><span class="comment">//输出各个边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; i--)<span class="comment">//n 个节点，所以有 n-1 条边。</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; pre[i] &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; endl;<span class="comment">// i 是节点编号，pre[i] 是 i 节点的前驱节点。他们构成一条边。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(g));<span class="comment">//各个点之间的距离初始化成很大的数</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;<span class="comment">//输入节点数和边数</span></span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;<span class="comment">//输出边的两个顶点和权重</span></span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b],w);<span class="comment">//存储权重</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">prim</span>();<span class="comment">//求最下生成树</span></span><br><span class="line">    <span class="comment">//getPath();//输出路径</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="八、查找"><a href="#八、查找" class="headerlink" title="八、查找"></a>八、查找</h2><p>查找表：同一类型的数据元素构成的集合</p>
<p>静态查找表：只查找</p>
<p>动态查找表：对查找表中的数据进行增添或删除操作</p>
<p>关键字分为主关键字（唯一的标识一个记录）和次关键字（可识别若干数据）      </p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>对于任意的N，当N较大时 ASL&#x3D;log_2(n+1)-1</p>
<p>二分查找效率较高，但只适用于顺序存储结构的有序表。</p>
<p>斐波那契查找：平均性能优于折半查找，但最坏情况差于折半查找。但其分割时只需加减运算。</p>
<p>插值查找：只适合关键字均匀分布的表，在表长较大的顺序表中的性能优于折半查找。</p>
<h6 id="分析题：二分查找插入元素后保持有序"><a href="#分析题：二分查找插入元素后保持有序" class="headerlink" title="分析题：二分查找插入元素后保持有序"></a>分析题：二分查找插入元素后保持有序</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *elem;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; SSTable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortForSSTableByBubling</span><span class="params">(SSTable &amp;st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;start sort\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = st.length;</span><br><span class="line">    <span class="type">bool</span> change = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; len &amp;&amp; change == <span class="literal">true</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        change = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.elem[j + <span class="number">1</span>] &lt; st.elem[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp = st.elem[j + <span class="number">1</span>];</span><br><span class="line">                st.elem[j + <span class="number">1</span>] = st.elem[j];</span><br><span class="line">                st.elem[j] = temp;</span><br><span class="line">                change = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sort of answer:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; st.elem[i] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;end of sort\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* * * * - - - - - - - - - - - - - - - - - - - - - - - - - - - * * * * */</span></span><br><span class="line"><span class="comment">//函数名： Search_Bin(SSTable ST,int key)</span></span><br><span class="line"><span class="comment">//参数：      （传入)SSTable，顺序表L</span></span><br><span class="line"><span class="comment">//参数：      （传入)int key，查找的关键字</span></span><br><span class="line"><span class="comment">//返回值：    int型,若找到，则函数值为该元素在表中的位置，否则为0</span></span><br><span class="line"><span class="comment">//功能：   在有序表ST中折半查找其关键字等于key的数据元素</span></span><br><span class="line"><span class="comment">/* * * * - - - - - - - - - - - - - - - - - - - - - - - - - - - * * * * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">1</span>;      <span class="comment">//查找次数</span></span><br><span class="line">    <span class="type">int</span> low = <span class="number">1</span>;          <span class="comment">//左边界变量</span></span><br><span class="line">    <span class="type">int</span> mid;              <span class="comment">//中间位置变量</span></span><br><span class="line">    <span class="type">int</span> high = ST.length; <span class="comment">//右边界变量，置区间初值</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key == ST.elem[mid])</span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">//找到待查元素</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; ST.elem[mid])</span><br><span class="line">                high = mid - <span class="number">1</span>; <span class="comment">//继续在前半区间进行查找</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid + <span class="number">1</span>; <span class="comment">//继续在后半区间进行查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search times=%d\n&quot;</span>, counter); <span class="comment">//输出查找次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//顺序表中不存在待查元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> kvalue; <span class="comment">//待查找的变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pro Version\n&quot;</span>;</span><br><span class="line">    SSTable L;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input the length of this LinkedArr:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    L.elem = (<span class="type">int</span> *)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    L.length = n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input data array:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;L.elem[i]);</span><br><span class="line">        <span class="built_in">SortForSSTableByBubling</span>(L);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input a key value:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;kvalue); <span class="comment">//输入关键字</span></span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">Search_Bin</span>(L, kvalue);</span><br><span class="line">    <span class="keyword">if</span> (pos)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the position is %d,the svalue is %d\n&quot;</span>, pos + <span class="number">1</span>, L.elem[pos]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cannot found!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 改进升级版，输入数据不需要排序，输入长度可以自定义 */</span></span><br></pre></td></tr></table></figure>



<h6 id="分析题：使用二分查找查找增序数组中的元素"><a href="#分析题：使用二分查找查找增序数组中的元素" class="headerlink" title="分析题：使用二分查找查找增序数组中的元素"></a>分析题：使用二分查找查找增序数组中的元素</h6><p>仅需将上述代码也可实现该功能。</p>
<h6 id="编程题：递归算法与非递归算法"><a href="#编程题：递归算法与非递归算法" class="headerlink" title="编程题：递归算法与非递归算法"></a>编程题：递归算法与非递归算法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Binary_Search_NoRe</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> low, high, mid;</span><br><span class="line">    low = <span class="number">1</span>;</span><br><span class="line">    high = n;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; a[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Binary_Search</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> key, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] == key)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; key)</span><br><span class="line">            <span class="built_in">Binary_Search</span>(arr, key, left, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">Binary_Search</span>(arr, key, mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="分析题：哈希函数的冲突处理"><a href="#分析题：哈希函数的冲突处理" class="headerlink" title="分析题：哈希函数的冲突处理"></a>分析题：哈希函数的冲突处理</h4><p>在线性表、树中，记录在结构中的相对位置是随机的，和记录的关键字之间不存在确定的关系。在理想的情况下希望不经过比较就能得到所查找的记录，则在记录的存储位置和他的关键字之间建立一个确定的对应关系（哈希函数）来让每一个关键字和结构中的存储位置相对应。</p>
<p>总的说：根据设定的哈希函数和处理冲突的方法将一组关键字映像到一个有限的连续的地址集上，并以关键子在地址集中的”像“作为在表中的存储位置，这种表就叫做<strong>哈希表</strong>这一映像过程就叫做哈希造表或散列，所得存储位置称<strong>哈希地址</strong>或<strong>散列地址。</strong></p>
<p>构建一个”好“的散列函数应遵守的条件：</p>
<ol>
<li>函数计算简单，每一关键字只能有一个散列地址与之对应。</li>
<li>函数的值域需要在表长的范围内，计算出的散列地址分布要均匀，尽量减少冲突。</li>
</ol>
<p>常用的构建哈希函数方法有：</p>
<ul>
<li>直接定址法：取关键字或关键字的某个线性函数值为哈希地址</li>
<li>数字分析法：从关键字中提取数字分布比较均匀的若干位作为散列地址，但事先必须明确知道所有的关键字每一位上各种数字的分布情况。</li>
<li>平方取中法：取关键字平方后的中间几位或其组合作为散列地址。用于不能事先了解关键字的所有情况，或者难以直接从关键字中找到取值比较分散的几位。</li>
<li>折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为散列地址。适用于散列地址的位数较少，关键字的位数较多，难于直接从关键字中找到取值比较分散的几位。</li>
<li>除留余数法</li>
</ul>
<h5 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h5><h6 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h6><p>将所有的记录都存储在散列表数组中，当某一记录关键字key的初始散列地址发生冲突时，以初始的散列地址为基础，采用合适的方法计算出另一个散列地址，若依旧发生冲突，在以此地址为基础求下一个散列地址。以此类推。<br>$$<br>H_i&#x3D;(H(key)+d_i)%m<br>$$</p>
<p>$$<br>H(key)为散列函数，m为散列表表长， d_i 为增量序列，根据d_i的取值方法可以进行分类<br>$$</p>
<ol>
<li><p>线性探测法</p>
<p> 将散列表看作循环表，发生冲突时，从冲突地址的下一个单元顺序寻找空单元，若在最后一个位置未发现空单元则从头开始寻找，直到发现空位置。若找不到空位置，则说明散列表容量已满，需要进行溢出处理。</p>
<p> 优点：只要散列表未填满，总能找到一个未发生冲突的地址。</p>
<p> 缺点：会产生”二次聚集：现象</p>
</li>
<li><p>二次探测法<br> $$<br> d_i在每一次计算时会发生变化，类似于d_i&#x3D;1^2，-1^2,2^2……，每一次发生冲突后就更换增量序列<br> $$</p>
</li>
<li><p>伪随机探测法<br> $$<br> d_i&#x3D; 伪随机序列<br> $$<br> 2，3方法都能避免“二次聚集”但不能保证一定会找到不发生冲突的地址。</p>
</li>
</ol>
<h6 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h6><p>每一个下标中都存储一个链表，相同哈希值的key直接插入到链表。</p>
<p><img src="https://img-blog.csdn.net/20180830153725165?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x2eWliaW44OTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><strong>这种方法的特点是表的大小和存储的数据数量差不多（大不了每个下标都只放一个节点，如果下标一样的都是放在同一下标的链表中，并没有占据新的下标），因此哈希桶的方法没有特别依赖于装载因子，哈希表快满时，它还是可以做到较好的效率，而开放地址法就需要保证装载因子。</strong></p>
<h4 id="编程题：索引顺序表的代码设计"><a href="#编程题：索引顺序表的代码设计" class="headerlink" title="编程题：索引顺序表的代码设计"></a>编程题：索引顺序表的代码设计</h4><p><img src="https://img-blog.csdnimg.cn/20200815163504310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTg3NzQw,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>索引顺序表可用来表示静态查找表。也可以称为分块查找，在表外新建一个”索引表“（索引表中包含两个内容：关键字：值为子表内的最大关键字；指针项：子表中的第一个记录在表中的位置）。索引表按分块有序，则表或者有序或者分块有序。</p>
<p>若设分块查找中将长度为n的表均匀分为b块，每块含有s个记录，当s&#x3D;n^(0.5)时分块查找的平均查找长度最小为n^(0.5)+1</p>
<h6 id="1-动态数组实现"><a href="#1-动态数组实现" class="headerlink" title="1.动态数组实现"></a>1.动态数组实现</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//using namespace std;</span></span><br><span class="line"><span class="comment">//typedef int ElemType;</span></span><br><span class="line"><span class="comment">//typedef struct &#123;</span></span><br><span class="line"><span class="comment">//	ElemType  maxValue;</span></span><br><span class="line"><span class="comment">//	int low, high;</span></span><br><span class="line"><span class="comment">//&#125;Index;</span></span><br><span class="line"><span class="comment">////顺序表储存实际元素</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//ElemType List[101];</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	<span class="type">char</span> info;</span><br><span class="line">&#125;Key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> maxkey;</span><br><span class="line">	<span class="type">int</span> address;</span><br><span class="line">&#125;Index;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_blo</span><span class="params">(Key K[], Index I[], <span class="type">int</span> key, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> low = L;<span class="comment">//索引表的起始位置</span></span><br><span class="line">	<span class="type">int</span> high = R;<span class="comment">//索引表的结束位置</span></span><br><span class="line">	<span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (low &lt; high)		<span class="comment">//先折半查找索引表</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (key == I[mid].maxkey)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (key &lt; I[mid].maxkey) <span class="comment">//缩小查找范围到左子序列</span></span><br><span class="line">				high = mid;</span><br><span class="line">			<span class="keyword">else</span>					<span class="comment">//缩小查找范围到右子序列</span></span><br><span class="line">				low = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i, end;</span><br><span class="line">	<span class="type">int</span> start = I[mid].address;	<span class="comment">//找key值所在的区间首地址</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mid == R)	<span class="comment">//确定查找的结束地址</span></span><br><span class="line">		end = len + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		end = I[mid + <span class="number">1</span>].address;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = start; i &lt; end; i++)<span class="comment">//再顺序查找该区间</span></span><br><span class="line">		<span class="keyword">if</span> (key == K[i].key)</span><br><span class="line">			<span class="keyword">return</span> i;			<span class="comment">//返回位置</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateIndexList</span><span class="params">(Key* K, Index* I,<span class="type">int</span> M,<span class="type">int</span> N)</span><span class="comment">//key无序时</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> len = M / N;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			I[i].maxkey = <span class="built_in">max</span>(I[i].maxkey, K[i].key);</span><br><span class="line">		&#125;</span><br><span class="line">		I[i].address = i * len;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindValue</span><span class="params">(Key* K, Index* I,<span class="type">int</span> N,<span class="type">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入需要查找的关键字:&quot;</span>);</span><br><span class="line">	cin &gt;&gt; key;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> j = <span class="built_in">Search_blo</span>(K, I, key, <span class="number">0</span>, N, M);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;关键字位置:%d\n&quot;</span>, j);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;关键字信息:%c\n&quot;</span>, K[j].info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Key* K;</span><br><span class="line">	Index* I;</span><br><span class="line">	<span class="type">int</span> i, M, N;</span><br><span class="line">	<span class="comment">//输入关键字及关键字信息</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入关键字个数:&quot;</span>);</span><br><span class="line">	cin &gt;&gt; M;</span><br><span class="line">	<span class="comment">//scanf(&quot;%d&quot;, &amp;M);</span></span><br><span class="line">	K = <span class="keyword">new</span> Key[M + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">//设立终止位置</span></span><br><span class="line">	<span class="comment">//K[M].info = &#x27;#&#x27;;</span></span><br><span class="line">	<span class="comment">//K = (Key*)malloc((M + 1) * sizeof(Key));</span></span><br><span class="line">	<span class="comment">//测试用例:1 a 2 b 3 c 4 d 5 e 6 f 7 g 8 h 9 i 10 j</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入所以关键字、关键字信息:\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">		cin &gt;&gt; K[i].key &gt;&gt; K[i].info;</span><br><span class="line">	<span class="comment">//输入索引表</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入索引个数:&quot;</span>);</span><br><span class="line">	cin&gt;&gt;N;</span><br><span class="line">	I = <span class="keyword">new</span> Index[N + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">//I = (Index*)malloc((N + 1) * sizeof(Index));</span></span><br><span class="line">	<span class="comment">//测试用例:4 1 6 5 10 7</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入所以最大关键字、起始地址:\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">		<span class="built_in">scanf_s</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;I[i].maxkey, &amp;I[i].address);</span><br><span class="line">	<span class="comment">//CreateIndexList(K,I,M,N);</span></span><br><span class="line">	<span class="built_in">FindValue</span>(K, I, M, N);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-顺序表实现"><a href="#2-顺序表实现" class="headerlink" title="2.顺序表实现"></a>2.顺序表实现</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	KeyType key;</span><br><span class="line">	InfoType info;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span><span class="comment">//顺序表</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType *R;</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;List,*SqList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	KeyType maxkey;</span><br><span class="line">	<span class="type">int</span> address;</span><br><span class="line">&#125;IndexType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span><span class="comment">//索引表</span></span><br><span class="line">&#123;</span><br><span class="line">	IndexType *D;</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;Index, *IndexList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L, IndexList &amp;I)</span><span class="comment">//初始化顺序表和索引表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	L = (List *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(List));	<span class="comment">//给顺序表分配空间</span></span><br><span class="line">	I = (Index *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Index));	<span class="comment">//给索引表分配空间</span></span><br><span class="line"></span><br><span class="line">	L-&gt;R = (ElemType *)<span class="built_in">malloc</span>(MAX * <span class="built_in">sizeof</span>(ElemType));		<span class="comment">//给顺序表数据域分配空间</span></span><br><span class="line">	I-&gt;D = (IndexType *)<span class="built_in">malloc</span>(MAX/<span class="number">3</span> *<span class="built_in">sizeof</span>(IndexType));	<span class="comment">//给索引表表数据域分配空间</span></span><br><span class="line"></span><br><span class="line">	L-&gt;length = <span class="number">0</span>;</span><br><span class="line">	I-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateList</span><span class="params">(SqList &amp;L, IndexList &amp;I)</span><span class="comment">//创建顺序表和索引表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		L-&gt;R[i].key = i;<span class="comment">//赋值</span></span><br><span class="line">		L-&gt;R[i].info = <span class="string">&#x27;a&#x27;</span>+i<span class="number">-1</span>;<span class="comment">//赋值</span></span><br><span class="line">		L-&gt;length++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//直接输入数据创建索引表</span></span><br><span class="line">	I-&gt;D[<span class="number">1</span>].maxkey = <span class="number">4</span>;	I-&gt;D[<span class="number">1</span>].address = <span class="number">1</span>;</span><br><span class="line">	I-&gt;D[<span class="number">2</span>].maxkey = <span class="number">6</span>;	I-&gt;D[<span class="number">2</span>].address = <span class="number">5</span>;</span><br><span class="line">	I-&gt;D[<span class="number">3</span>].maxkey = <span class="number">10</span>;I-&gt;D[<span class="number">3</span>].address = <span class="number">7</span>;</span><br><span class="line">	I-&gt;length = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">(SqList L)</span><span class="comment">//遍历顺序表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= L-&gt;length; i++)<span class="comment">//关键字遍历</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, L-&gt;R[i].key);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i= <span class="number">1</span>; i &lt;= L-&gt;length; i++)<span class="comment">//关键字信息遍历</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,L-&gt;R[i].info);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Blo</span><span class="params">(SqList L, IndexList I, KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> low = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> high = I-&gt;length;</span><br><span class="line">	<span class="type">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(low &lt; high)		<span class="comment">//先折半查找索引表</span></span><br><span class="line">	&#123;		</span><br><span class="line">		<span class="keyword">if</span>(key == I-&gt;D[mid].maxkey)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(key &lt; I-&gt;D[mid].maxkey) <span class="comment">//缩小查找范围到左子序列</span></span><br><span class="line">				high = mid;</span><br><span class="line">			<span class="keyword">else</span>					   <span class="comment">//缩小查找范围到右子序列</span></span><br><span class="line">				low = mid <span class="number">+1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> end, start = I-&gt;D[mid].address;	<span class="comment">//找key值所在的区间首地址</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(mid == I-&gt;length)</span><br><span class="line">		end = L-&gt;length + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		end = I-&gt;D[mid<span class="number">+1</span>].address;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt; end; i++)<span class="comment">//再顺序查找该区间</span></span><br><span class="line">		<span class="keyword">if</span>(key == L-&gt;R[i].key)</span><br><span class="line">			<span class="keyword">return</span> i;			<span class="comment">//返回位置</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SqList L;</span><br><span class="line">	IndexList I;</span><br><span class="line">	<span class="built_in">InitList</span>(L, I);</span><br><span class="line">	<span class="built_in">CreateList</span>(L, I);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;顺序表、索引表创建完成!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;顺序表表长 = %d\n&quot;</span>, L-&gt;length);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;索引表表长 = %d\n&quot;</span>, I-&gt;length);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;关键字信息遍历:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">DispList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m, key;	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入需要查找的关键字:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);</span><br><span class="line"></span><br><span class="line">		m = <span class="built_in">Search_Blo</span>(L, I, key);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;关键字位置:%d\n&quot;</span>, m);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;关键字信息:%c\n\n&quot;</span>, L-&gt;R[m].info);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="3-链表实现"><a href="#3-链表实现" class="headerlink" title="3.链表实现"></a>3.链表实现</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span></span><br><span class="line">&#123;</span><br><span class="line">	KeyType key;</span><br><span class="line">	InfoType info;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	KeyType maxkey; </span><br><span class="line">	LinkList address;</span><br><span class="line">&#125;Index;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span><span class="comment">//初始化单链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	L = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;链表已初始化!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateList</span><span class="params">(LinkList &amp;L)</span><span class="comment">//创建单链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList p = L;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span> ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		LNode *s;<span class="comment">//定义一个结点</span></span><br><span class="line">		s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));<span class="comment">//为结点分配空间</span></span><br><span class="line">		<span class="comment">//给结点赋值</span></span><br><span class="line">		s-&gt;key = i;</span><br><span class="line">		s-&gt;info = <span class="string">&#x27;a&#x27;</span>+i<span class="number">-1</span>;</span><br><span class="line">		<span class="comment">//尾插法将结点依次接入单链表</span></span><br><span class="line">		s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		p-&gt;next = s;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;链表创建成功!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateIndex</span><span class="params">(Index *I, LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	LinkList p = L;</span><br><span class="line">	I[<span class="number">1</span>].maxkey = <span class="number">4</span>;</span><br><span class="line">	I[<span class="number">2</span>].maxkey = <span class="number">6</span>;</span><br><span class="line">	I[<span class="number">3</span>].maxkey = <span class="number">10</span>;	</span><br><span class="line">	<span class="comment">//索引表的指针项为块区域的首结点</span></span><br><span class="line">	I[<span class="number">1</span>].address = p-&gt;next;	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	I[<span class="number">2</span>].address = p;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	I[<span class="number">3</span>].address = p;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;索引表建立完成!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">(LinkList &amp;L)</span>	<span class="comment">//遍历单链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList p = L, q = L;</span><br><span class="line">	<span class="keyword">while</span>(p-&gt;next)</span><br><span class="line">	&#123;	</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;key);<span class="comment">//遍历关键字</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(q-&gt;next)</span><br><span class="line">	&#123;		</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, q-&gt;info);<span class="comment">//遍历关键字信息</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LinkList <span class="title">Search_Blo</span><span class="params">(LinkList L, Index *I, KeyType key, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> low = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> high = len;</span><br><span class="line">	<span class="type">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(low &lt; high)		<span class="comment">//先折半查找索引表</span></span><br><span class="line">	&#123;		</span><br><span class="line">		<span class="keyword">if</span>(key == I[mid].maxkey)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(key &lt; I[mid].maxkey) <span class="comment">//缩小查找范围到左子序列</span></span><br><span class="line">				high = mid;</span><br><span class="line">			<span class="keyword">else</span>					   <span class="comment">//缩小查找范围到右子序列</span></span><br><span class="line">				low = mid <span class="number">+1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LinkList p = I[mid].address;	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(p != I[mid<span class="number">+1</span>].address)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;key == key)</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList L;</span><br><span class="line">	<span class="built_in">InitList</span>(L);	</span><br><span class="line">	<span class="built_in">CreateList</span>(L);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;链表关键字信息:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">DispList</span>(L);</span><br><span class="line">	</span><br><span class="line">	Index I[<span class="number">4</span>];</span><br><span class="line">	<span class="built_in">CreateIndex</span>(I, L);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入需要查找的关键字:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);</span><br><span class="line">		</span><br><span class="line">		LinkList k = <span class="built_in">Search_Blo</span>(L, I, key, <span class="number">3</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;关键字信息:%c\n\n&quot;</span>, k-&gt;info);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="九、排序"><a href="#九、排序" class="headerlink" title="九、排序"></a>九、排序</h2><p>已知一个数据序列对其排序，并按照指定方法写出每一步排序过程</p>
<p><img src="https://s3.bmp.ovh/imgs/2021/12/3712c42a8a875ac2.png"></p>
<p>去年：</p>
<p>堆排序考画图</p>
<p>快排写结果</p>
<p>归并计算时间复杂度</p>
<h4 id="1-内部排序与外部排序"><a href="#1-内部排序与外部排序" class="headerlink" title="1.内部排序与外部排序"></a>1.内部排序与外部排序</h4><p>内部排序：不需要访问外存</p>
<p>外部排序：由于排序记录量很大  在内存不可能完成</p>
<p>内部排序：<strong>逐步扩大记录的有序序列长度</strong>的过程</p>
<h4 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a><strong>2.插入排序</strong></h4><h5 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h5><p><strong>平均复杂度O n<sup>2</sup>		最坏复杂度 O n<sup>2</sup>		稳定的</strong></p>
<p>双层循环   先按顺序  再从该元素位置减减前推   直到找到合适位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; <span class="number">7</span>;i++) <span class="comment">//tag</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp=a[i];</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; a[j]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            a[j<span class="number">+1</span>]=a[j];    <span class="comment">//将较大元素后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        a[j<span class="number">+1</span>]=temp;        <span class="comment">//temp插入正确的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">12</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">6</span>,<span class="number">31</span>,<span class="number">24</span>&#125;;</span><br><span class="line">  	<span class="type">int</span> len = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);<span class="comment">// </span></span><br><span class="line">    <span class="built_in">InsertSort</span>(a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假如当初始为<code>12，15，9，20，6，31，24</code>时 </p>
<p>第一趟temp 为 <code>15</code> 然后结束 <code>12,15,9,20,6,31,24</code> <!-- tag --></p>
<p>第二趟temp 为 <code>9</code>  往前移动 然后结束 <code>9,12,15,20,6,31,24 </code></p>
<p>第三趟temp 为 <code>20</code> 然后结束  <code>9,12,15,20,6,31,24</code> </p>
<p>第四趟temp 为<code>6</code>比前面的小 故移动  <code>6,9,12,15,20,31,24</code></p>
<p>第五趟temp为<code>31</code>比前面大 故不移动 <code>6,9,12,15,20,31,24</code></p>
<p>第六趟temp为 <code>24</code>比<code>31</code>小 故移动一位 <code>6,9,12,15,20,24,31</code> </p>
<p><strong>重点是默认第一个已被排序,一共7 - 1 &#x3D; 6轮</strong></p>
<p><img src="C:\Users\26898\AppData\Roaming\Typora\typora-user-images\image-20241118225509767.png" alt="image-20241118225509767"></p>
<p><img src="C:\Users\26898\AppData\Roaming\Typora\typora-user-images\image-20241118225617595.png" alt="image-20241118225617595"></p>
<h5 id="折半插入法"><a href="#折半插入法" class="headerlink" title="折半插入法"></a>折半插入法</h5><p>同样依次插入   但在查找时是使用二分</p>
<p>依旧和直接插入一样是 <strong>O n<sup>2</sup></strong>   但<strong>平均性能优于直接插入排序</strong>     还是<strong>稳定的</strong></p>
<p>减少了比较次数  但没有减少移动次数</p>
<h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h5><p>不稳定     时间复杂度由增量定</p>
<p><strong>设置增量  x</strong>     为数组长度一半</p>
<p>以该增量   按序号i 、i+x为一组		此时场上就是n&#x2F;2组</p>
<p>组内进行排序   小前大后</p>
<p>完成后   增量x 除以2</p>
<p>此时即 i、i+x、i+2x、i+3x为一组（均为之前一组中较小的）</p>
<p>组内再进行排序</p>
<p>增量x 再除以2</p>
<p>组内再进行排序</p>
<p>直到x为1  并完成排序   即结束排序</p>
<p>(为1进行排序时	即可保证比较交换的次数较少</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> gap = n;</span><br><span class="line">	<span class="keyword">while</span> (gap&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//每次对gap折半操作</span></span><br><span class="line">		gap = gap / <span class="number">2</span>;</span><br><span class="line">		<span class="comment">//单趟排序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - gap; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> end = i;</span><br><span class="line">			<span class="type">int</span> tem = arr[end + gap];</span><br><span class="line">			<span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (tem &lt; arr[end])</span><br><span class="line">				&#123;</span><br><span class="line">					arr[end + gap] = arr[end];</span><br><span class="line">					end -= gap;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			arr[end + gap] = tem;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)  cin &gt;&gt;arr[i];</span><br><span class="line">    <span class="built_in">ShellSort</span>(arr,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h4><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>双重循环  两两比较   每趟将小的往前推一格   大的直接冒到最后（升序）</p>
<p><strong>最好时是 O n  最坏时是 O n<sup>2</sup>    平均O n<sup>2</sup>    稳定的</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j, temp;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span> - j; i++)</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			temp = a[i];</span><br><span class="line">			a[i] = a[i + <span class="number">1</span>];</span><br><span class="line">			a[i + <span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span> &#125;;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;排序前：&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">BubbleSort</span>(arr, len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;排序后：&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点是从i(i&#x3D;&#x3D; 0)开始与i + 1交换</p>
<p>初始数组为<code> 5, 8, 6, 3, 9, 2, 1, 7</code></p>
<p>第一轮按照排序规则 依次交换<code>5 6 3 8 2 1 7 9</code> <!--tag--></p>
<p>第二轮<code>5 3 6 2 1 7 8 9</code></p>
<p>第三轮<code>3 5 2 1 6 7 8 9</code></p>
<p>第四轮<code>3 2 1 5 6 7 8 9</code></p>
<p>第五轮<code>2 1 3 5 6 7 8 9</code></p>
<p>第六轮<code>1 2 3 5 6 7 8 9</code></p>
<p><strong>一共len轮</strong> </p>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>选一个数作为比较对象    所有元素与之比较   小的到左边  大的到右边    再递归进行两边元素（双指针进行）</p>
<p>平均时间复杂度    <strong>O n log<sub>2</sub>n</strong>       不稳定的</p>
<p><strong>快速排序不适于对原本有序或基本有序的记录序列进行排序。</strong></p>
<p>最坏情况下   快速排序算法时间复杂度总是  O n<sup>2</sup> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">快排属于分治算法，而分治算法一般都有三步</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>分成子问题</span><br><span class="line"><span class="number">2.</span>递归处理子问题</span><br><span class="line"><span class="number">3.</span>子问题的合并</span><br><span class="line"></span><br><span class="line">而在快排中的体现就是：</span><br><span class="line"><span class="number">1.</span>找到一个分界点 将排序区间分为两段（问题所在）</span><br><span class="line"><span class="number">2.</span>递归处理两个子区间</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N],l,r;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// x 就是其分界点 而i与j是这个序列的首位指针 用于将指针所指的值排序</span></span><br><span class="line">	<span class="type">int</span> x = q[r + l &gt;&gt; <span class="number">1</span>],i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;<span class="comment">//递归的终止情况</span></span><br><span class="line">	<span class="keyword">while</span>(i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i] &lt; x);<span class="comment">//之所以要i = l - 1 j = r + 1是因为要使用do while 先加了一次</span></span><br><span class="line">		<span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">		<span class="keyword">if</span>(i &lt; j)</span><br><span class="line">		<span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 递归处理子问题</span></span><br><span class="line">	<span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">	<span class="built_in">quick_sort</span>(q,j + <span class="number">1</span>,r);</span><br><span class="line">	<span class="comment">//快排不需要处理子问题合并这一操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//ios::sync_with_stdio(0);</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; q[i];</span><br><span class="line">	<span class="built_in">quick_sort</span>(q,<span class="number">0</span>,n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cout &lt;&lt; q[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h5><p>直接多次遍历求最小值   将最小值依次取出  与前交换<br>时间复杂度   总是O n<sup>2</sup>   <strong>不稳定</strong></p>
<h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><p><img src="C:\Users\26898\AppData\Roaming\Typora\typora-user-images\image-20241121163656188.png" alt="image-20241121163656188"></p>
<p>小根堆    或     大根堆</p>
<p><strong>完全二叉树</strong></p>
<p>小根堆   输出堆顶元素后    以最后一个元素替代       然后 由根结点与左右子树比较    小者交换</p>
<p>重复直至叶子结点</p>
<p>无论最好还是最坏   时间复杂度总是<strong>O nlog<sub>2</sub>n</strong>		空间复杂度需要<strong>O n</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n , m;</span><br><span class="line"><span class="type">int</span> h[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------模板开始--------------------</span></span><br><span class="line"><span class="comment">// 这个模板的作用是父节点和其两个孩子节点的最小值，再交换父节点和这个最小值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span> &lt;= cnt &amp;&amp; h[u*<span class="number">2</span>] &lt; h[t]) t = u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u*<span class="number">2</span><span class="number">+1</span>] &lt; h[t]) t = u*<span class="number">2</span><span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u!=t)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u],h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t); <span class="comment">// 递归处理这个输入的值，直到它down到不能down为止，即整棵树又变成了一个小根堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -----------------------------模板结束--------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]); <span class="comment">// h[]来存输入的n个节点，注意，节点的下标要从1开始</span></span><br><span class="line"></span><br><span class="line">    cnt = n; </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        cnt来存节点的最大下标,因为找左右孩子需要用2*u和2*u+1，</span></span><br><span class="line"><span class="comment">        为了防止边界值问题，需要判断2*u &lt; n,2*u+1&lt;n;</span></span><br><span class="line"><span class="comment">        并且，cnt也可以看成指向堆尾的一个指针。</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用down函数将整棵树调整为一个小根堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span>;i;i--) <span class="built_in">down</span>(i); <span class="comment">// 从2分之n开始down，建堆，时间复杂度为O(n)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,h[<span class="number">1</span>]); <span class="comment">// 输出堆顶的数，即为当前数列的最小值</span></span><br><span class="line">        h[<span class="number">1</span>] = h[cnt--];  <span class="comment">// 将堆最后一个数放到堆顶，cnt--使得在逻辑上删除这个数</span></span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>); <span class="comment">// 再将堆顶down下去，使得整棵树又变成了一个小根堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>重点要注意的是每完成一个大&#x2F;小根堆才算一趟</strong></p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>内部排序通常为2路归并排序</p>
<p>首先将序列分为n&#x2F;2组（每组两个）</p>
<p>各组进行排序   再两两合并排序</p>
<p>进行log<sub>2</sub>n趟</p>
<p>递归处理</p>
<p><strong>时间效率 nlog<sub>2</sub>n 空间效率 n    有稳定性</strong>  </p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>不需要比较</p>
<p>按照位数进行排序</p>
<p>有几位就排几次</p>
<p>从低位次到高位次    分别进行</p>
<p>最高位结束即排序结束</p>
<p><em><em>时间复杂度为 O(k</em>(n+m))      k为关键字个数   n为元素个数   m为关键字取值范围为m个值(比如0-9)</em>*</p>
<p><strong>稳定的</strong></p>
<p><img src="https://s2.loli.net/2024/11/21/kvF4aCr6BgSWUJm.png" alt="mmd2.png"></p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="按时间复杂度来说"><a href="#按时间复杂度来说" class="headerlink" title="按时间复杂度来说"></a><strong>按时间复杂度来说</strong></h5><p>有三类排序方法</p>
<p>-O nlogn   </p>
<p>快速排序    堆排序    归并排序     其中以快速排序最佳</p>
<p>-O n<sup>2</sup></p>
<p>直接插入排序    冒泡排序   简单选择排序    </p>
<p>其中以直接插入最好   特别是<strong>对关键字近似有序的记录序列</strong></p>
<p>-O n</p>
<p>基数排序</p>
<p>当待排序列   按关键字有序时     直接插入排序和冒泡排序（优化后）能达到O n的时间复杂度</p>
<p>而对于快速排序而言   这是最不好的情况    此时时间性能退化为O n<sup>2</sup> 应是尽量避免的情况。</p>
<p>原因：快速排序的核心是<strong>分治法</strong>，通过选定一个“基准元素”，将序列划分为两部分：小于基准和大于基准的两部分。如果序列有序，且选择的基准元素总是最小或最大值，划分出的子序列是极不均匀的。</p>
<p><strong>一个子序列包含 n−1个元素；另一个子序列为空</strong>。</p>
<p>这样，递归深度退化为 n，每一层仍需要 O(n) 的时间。</p>
<p>总体复杂度变为 O(n2)。</p>
<p><strong>简单选择排序、堆排序和归并排序的时间性能不随序列中关键字的分布而改变</strong>。</p>
<h5 id="按空间上"><a href="#按空间上" class="headerlink" title="按空间上"></a><strong>按空间上</strong></h5><p>所有简单排序  和堆排序   空间复杂度是O 1</p>
<p>快排为<strong>O logn</strong> 为栈所需的辅助空间</p>
<p>归并排序  空间最多   为<strong>O n</strong></p>
<p>链式基数排序   为<strong>O rd</strong></p>
<h5 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a><strong>稳定性</strong></h5><p>针对多关键字排序   必须采用稳定的排序方法</p>
<p>快速排序和堆排序是不稳定的排序方法</p>
<h5 id="时间复杂度最坏的情况"><a href="#时间复杂度最坏的情况" class="headerlink" title="时间复杂度最坏的情况"></a><strong>时间复杂度最坏的情况</strong></h5><p>除基数排序外  其他方法都是基于 <strong>比较关键字</strong>的排序方法   可以证明其最快的复杂度为O n logn  </p>
<p>day 2024.12.2  奈绪保佑我数据结构满分  冲！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ranren.zeabur.app">ranren</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ranren.zeabur.app/2024/11/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%94%E8%AF%95/">https://ranren.zeabur.app/2024/11/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%94%E8%AF%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ranren.zeabur.app" target="_blank">Ranren</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BA%94%E8%AF%95/">应试</a></div><div class="post-share"><div class="social-share" data-image="https://s2.loli.net/2024/10/23/txgP5ysfRUvCk6p.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/2024/11/22/%E5%8D%81%E4%B8%80%E6%9C%88%E4%BA%8C%E5%8D%81%E4%BA%8C%E6%97%A5%E6%9D%82%E6%83%B3/" title="十一月二十二日杂想"><img class="cover" src="https://s2.loli.net/2024/10/23/4aJSdzXWrCtAn75.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">十一月二十二日杂想</div></div></a><a class="next-post pull-right" href="/2024/10/30/%E5%A4%A7%E4%B8%80%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93/" title="大一回顾总结"><img class="cover" src="https://s2.loli.net/2024/10/23/k7mJRoSZOrLCiu6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">大一回顾总结</div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="/img/avater.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">ranren</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ranren-1"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一般通过</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.1.</span> <span class="toc-text">一、绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">基本概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">线性表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">顺序表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.0.4.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%86%E7%BD%AE%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.0.4.1.</span> <span class="toc-text">逆置链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%99%E5%AE%9A%E6%95%B0%E7%BB%84%E5%BB%BA%E7%AB%8B%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.0.4.2.</span> <span class="toc-text">给定数组建立链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8%E5%92%8C%E4%B8%8D%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.0.4.3.</span> <span class="toc-text">带头节点链表和不带头结点链表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.0.4.3.1.</span> <span class="toc-text">带头结点链表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8D%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8%EF%BC%9A"><span class="toc-number">1.1.0.4.3.2.</span> <span class="toc-text">不带头节点链表：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E9%A2%98%EF%BC%9A%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%88%E6%8C%89%E5%8D%87%E5%BA%8F%E7%94%B1%E5%B0%8F%E5%88%B0%E5%A4%A7%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">1.1.0.4.4.</span> <span class="toc-text">分析题：带头双向链表（按升序由小到大排序）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%9A%E5%B8%A6%E5%A4%B4%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%88%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7%E6%8E%92%E5%88%97%EF%BC%8C%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="toc-number">1.1.0.4.5.</span> <span class="toc-text">编程题：带头循环单链表（将数据从小到大排列，去除重复数据）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%88"><span class="toc-number">1.2.</span> <span class="toc-text">二、栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">栈的构建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DFS%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">DFS算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%98%9F%E5%88%97"><span class="toc-number">1.3.</span> <span class="toc-text">三、队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E9%98%9F%E5%88%97"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">链式存储队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">循环队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">四、数组和广义表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E8%A1%8C%E4%BC%98%E5%85%88%E4%B8%8E%E5%88%97%E4%BC%98%E5%85%88"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">数组的行优先与列优先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">广义表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%B8%B2"><span class="toc-number">1.5.</span> <span class="toc-text">五、串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-BF-%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">1.BF(暴力匹配)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-KMP%E5%8C%B9%E9%85%8D"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">2.KMP匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%A0%E9%99%A4%E4%B8%B2%E4%B8%AD%E7%9B%B8%E5%90%8C%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.5.0.3.</span> <span class="toc-text">3.删除串中相同的元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%A0%91"><span class="toc-number">1.6.</span> <span class="toc-text">六、树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89"><span class="toc-number">1.7.</span> <span class="toc-text">1.基本定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.0.2.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.0.3.</span> <span class="toc-text">满二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.0.4.</span> <span class="toc-text">完全二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">1.7.0.5.</span> <span class="toc-text">哈夫曼树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86"><span class="toc-number">1.8.</span> <span class="toc-text">2.二叉树的创建和遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE"><span class="toc-number">1.9.</span> <span class="toc-text">3.二叉树的相关题目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%99%E5%AE%9A%E5%89%8D-%E5%90%8E-%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%8C%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BD%A2%E6%80%81"><span class="toc-number">1.9.0.1.</span> <span class="toc-text">(1)给定前(后)遍历顺序和中序遍历，求二叉树的形态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E9%80%92%E5%BD%92%E6%A8%A1%E6%8B%9F"><span class="toc-number">1.9.0.1.1.</span> <span class="toc-text">方法一：递归模拟</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E7%9F%A9%E9%98%B5%E6%9A%B4%E5%8A%9B"><span class="toc-number">1.9.0.1.2.</span> <span class="toc-text">方法二：矩阵暴力</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B1%82%E5%BA%A6%E4%B8%BA0%E3%80%811%E3%80%812%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-number">1.9.0.2.</span> <span class="toc-text">(2)求度为0、1、2的节点个数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">1.10.</span> <span class="toc-text">4.哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81"><span class="toc-number">1.10.0.1.</span> <span class="toc-text">哈夫曼的编码与解码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.10.0.2.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.10.0.3.</span> <span class="toc-text"></span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%9B%BE"><span class="toc-number">1.11.</span> <span class="toc-text">七、图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%A2%86%E6%8E%A5%E8%A1%A8%E7%89%88%E6%9C%AC%E7%9A%84Dijkstra"><span class="toc-number">1.11.0.1.</span> <span class="toc-text">图的领接表版本的Dijkstra</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E4%BC%98%E5%8C%96"><span class="toc-number">1.11.0.2.</span> <span class="toc-text">堆优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.11.0.3.</span> <span class="toc-text">拓扑排序的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.11.0.4.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Kruskal"><span class="toc-number">1.11.0.4.1.</span> <span class="toc-text">(1)Kruskal</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Prim"><span class="toc-number">1.11.0.4.2.</span> <span class="toc-text">(2)Prim</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%9F%A5%E6%89%BE"><span class="toc-number">1.12.</span> <span class="toc-text">八、查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.12.0.1.</span> <span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%E5%90%8E%E4%BF%9D%E6%8C%81%E6%9C%89%E5%BA%8F"><span class="toc-number">1.12.0.1.0.1.</span> <span class="toc-text">分析题：二分查找插入元素后保持有序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E9%A2%98%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%9F%A5%E6%89%BE%E5%A2%9E%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.12.0.1.0.2.</span> <span class="toc-text">分析题：使用二分查找查找增序数组中的元素</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%9A%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="toc-number">1.12.0.1.0.3.</span> <span class="toc-text">编程题：递归算法与非递归算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E9%A2%98%EF%BC%9A%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86"><span class="toc-number">1.12.0.2.</span> <span class="toc-text">分析题：哈希函数的冲突处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.12.0.2.1.</span> <span class="toc-text">处理冲突的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="toc-number">1.12.0.2.1.1.</span> <span class="toc-text">开放地址法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="toc-number">1.12.0.2.1.2.</span> <span class="toc-text">链地址法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%9A%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.12.0.3.</span> <span class="toc-text">编程题：索引顺序表的代码设计</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.12.0.3.0.1.</span> <span class="toc-text">1.动态数组实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.12.0.3.0.2.</span> <span class="toc-text">2.顺序表实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.12.0.3.0.3.</span> <span class="toc-text">3.链表实现</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.</span> <span class="toc-text">九、排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.0.1.</span> <span class="toc-text">1.内部排序与外部排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.0.2.</span> <span class="toc-text">2.插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.0.2.1.</span> <span class="toc-text">直接插入排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%B3%95"><span class="toc-number">1.13.0.2.2.</span> <span class="toc-text">折半插入法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.0.2.3.</span> <span class="toc-text">希尔排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.0.3.</span> <span class="toc-text">交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.0.3.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.0.3.2.</span> <span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.0.4.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.0.4.1.</span> <span class="toc-text">简单选择排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.0.4.2.</span> <span class="toc-text">堆排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.0.5.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.0.6.</span> <span class="toc-text">基数排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.13.0.7.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9D%A5%E8%AF%B4"><span class="toc-number">1.13.0.7.1.</span> <span class="toc-text">按时间复杂度来说</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E7%A9%BA%E9%97%B4%E4%B8%8A"><span class="toc-number">1.13.0.7.2.</span> <span class="toc-text">按空间上</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">1.13.0.7.3.</span> <span class="toc-text">稳定性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9C%80%E5%9D%8F%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.13.0.7.4.</span> <span class="toc-text">时间复杂度最坏的情况</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/23/learning/" title="deeplearning1-machinelearning"><img src="https://s2.loli.net/2024/10/23/WHC76OK4VrepMbQ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="deeplearning1-machinelearning"/></a><div class="content"><a class="title" href="/2025/01/23/learning/" title="deeplearning1-machinelearning">deeplearning1-machinelearning</a><time datetime="2025-01-23T05:06:33.000Z" title="发表于 2025-01-23 13:06:33">2025-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/16/git%E4%BD%BF%E7%94%A8/" title="git使用"><img src="https://s2.loli.net/2024/10/23/6Kwd2DAtmk7eqoT.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="git使用"/></a><div class="content"><a class="title" href="/2025/01/16/git%E4%BD%BF%E7%94%A8/" title="git使用">git使用</a><time datetime="2025-01-16T09:34:01.000Z" title="发表于 2025-01-16 17:34:01">2025-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/24/%E6%9C%9F%E6%9C%AB%E5%91%A8/" title="期末周"><img src="https://s2.loli.net/2024/10/23/2USLkrpdsceYfJg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="期末周"/></a><div class="content"><a class="title" href="/2024/12/24/%E6%9C%9F%E6%9C%AB%E5%91%A8/" title="期末周">期末周</a><time datetime="2024-12-24T08:25:00.000Z" title="发表于 2024-12-24 16:25:00">2024-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/06/%E5%8D%81%E4%BA%8C%E6%9C%88%E5%85%AD%E6%97%A5%E6%9C%89%E6%84%9F/" title="十二月六日有感"><img src="https://s2.loli.net/2024/10/23/hnjQPWyUMDZX1wK.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="十二月六日有感"/></a><div class="content"><a class="title" href="/2024/12/06/%E5%8D%81%E4%BA%8C%E6%9C%88%E5%85%AD%E6%97%A5%E6%9C%89%E6%84%9F/" title="十二月六日有感">十二月六日有感</a><time datetime="2024-12-06T03:12:23.000Z" title="发表于 2024-12-06 11:12:23">2024-12-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/22/%E5%8D%81%E4%B8%80%E6%9C%88%E4%BA%8C%E5%8D%81%E4%BA%8C%E6%97%A5%E6%9D%82%E6%83%B3/" title="十一月二十二日杂想"><img src="https://s2.loli.net/2024/10/23/4aJSdzXWrCtAn75.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="十一月二十二日杂想"/></a><div class="content"><a class="title" href="/2024/11/22/%E5%8D%81%E4%B8%80%E6%9C%88%E4%BA%8C%E5%8D%81%E4%BA%8C%E6%97%A5%E6%9D%82%E6%83%B3/" title="十一月二十二日杂想">十一月二十二日杂想</a><time datetime="2024-11-22T07:52:23.000Z" title="发表于 2024-11-22 15:52:23">2024-11-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-color: #000000;"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By ranren</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>